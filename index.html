<!DOCTYPE html>
<html>
<head>
<base target="_top">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Cake 3D Mobile Pro</title>
<link rel="manifest" href="./manifest.json">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<style>
/* --- 1. GLOBAL STYLES --- */
:root {
  --primary: #ec4899; --primary-active: #db2777;
  --bg-ui: rgba(255, 255, 255, 0.96);
  --text: #1f2937; --border: #e5e7eb;
  --safe-area-bottom: env(safe-area-inset-bottom, 20px);
  --toolbar-h: 65px;
}
* { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
body { 
  margin: 0; padding: 0; font-family: 'Inter', sans-serif; 
  background: #f0f2f5; color: var(--text); overflow: hidden; 
  touch-action: none; user-select: none;
  overscroll-behavior: none; /* <--- –ë–õ–û–ö–ò–†–£–ï–¢ –û–ë–ù–û–í–õ–ï–ù–ò–ï –°–í–ê–ô–ü–û–ú */
}

input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
input[type=number] { -moz-appearance: textfield; }

#app { position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; }
#viewer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; background: radial-gradient(circle at center, #f8f9fa 0%, #eef2f6 100%); }

/* --- 2. UI LAYER --- */
#ui-layer { 
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; 
  pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
}
.pointer-events-auto { pointer-events: auto; }

/* TOP BAR */
/* –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –í–ï–†–•–ù–ò–ô –ë–ê–† */
.top-bar { 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    padding: 10px; 
    gap: 12px; /* –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–µ–º –∏ –∫–Ω–æ–ø–∫–∞–º–∏ */
    margin-top: 10px; 
    flex-wrap: wrap; /* –ß—Ç–æ–±—ã –Ω–∞ –æ—á–µ–Ω—å —É–∑–∫–∏—Ö —ç–∫—Ä–∞–Ω–∞—Ö –ø–µ—Ä–µ–Ω–æ—Å–∏–ª–æ—Å—å */
    pointer-events: none; /* –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–ª–∏–∫–∏ —Å–∫–≤–æ–∑—å –ø—É—Å—Ç–æ–µ –º–µ—Å—Ç–æ */
}

/* –ü–ê–ù–ï–õ–¨ –í–´–ë–û–†–ê –¢–û–†–¢–ê (–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä) */
.cake-selector {
    background: var(--bg-ui); /* –ë–µ–ª—ã–π —Ñ–æ–Ω –ø–ª–∞—à–∫–∏ */
    border-radius: 24px;      /* –°–∏–ª—å–Ω–æ–µ —Å–∫—Ä—É–≥–ª–µ–Ω–∏–µ */
    
    /* –£–≤–µ–ª–∏—á–∏–ª–∏ –æ—Ç—Å—Ç—É–ø—ã, —á—Ç–æ–±—ã –∫–Ω–æ–ø–∫–∏ –Ω–µ –ø—Ä–∏–ª–∏–ø–∞–ª–∏ –∫ –∫—Ä–∞—é */
    padding: 6px 8px;         
    
    display: flex;
    align-items: center;
    
    /* –£–≤–µ–ª–∏—á–∏–ª–∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏, –∫–∞–∫ –Ω–∞ –≤—Ç–æ—Ä–æ–π –ø–ª–∞—à–∫–µ */
    gap: 8px;                 
    
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    pointer-events: auto;
    flex-shrink: 0;
}
/* –ö–ù–û–ü–ö–ò –í–ù–£–¢–†–ò –ü–ê–ù–ï–õ–ò (A, B, A+B) */
.seg-btn {
    /* –î–µ–ª–∞–µ–º –∫–Ω–æ–ø–∫–∏ –∫—Ä—É–≥–ª—ã–º–∏ */
    width: 36px;
    height: 36px;
    border-radius: 50%;
    
    /* –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–æ–Ω –∏ —Ä–∞–º–∫–∏ */
    background: transparent;
    border: none;
    
    /* –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç */
    display: flex;
    align-items: center;
    justify-content: center;
    
    font-size: 14px; font-weight: bold; color: #333;
    cursor: pointer;
    transition: all 0.2s ease; /* –ü–ª–∞–≤–Ω–æ—Å—Ç—å */
}

/* –ü—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –º—ã—à–∏ - –ª–µ–≥–∫–∏–π —Å–µ—Ä—ã–π —Ñ–æ–Ω */
.seg-btn:hover {
    background: #f3f4f6;
}

/* –ê–∫—Ç–∏–≤–Ω–∞—è –∫–Ω–æ–ø–∫–∞ - –†–æ–∑–æ–≤–∞—è –∏ –∫—Ä—É–≥–ª–∞—è */
.seg-btn.active {
    background: #ec4899;
    color: white;
    box-shadow: 0 2px 5px rgba(236, 72, 153, 0.4);
}

.top-tools { 
    /* –£–±—Ä–∞–ª–∏ position: absolute */
    position: static; 
    display: flex; 
    gap: 8px; 
    pointer-events: auto; 
    
    /* –î–æ–±–∞–≤–∏–ª–∏ —Å—Ç–∏–ª—å "–æ—Å—Ç—Ä–æ–≤–∫–∞", –∫–∞–∫ —É –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è */
    background: var(--bg-ui);
    padding: 4px 8px;
    border-radius: 24px; /* –ß—É—Ç—å –±–æ–ª–µ–µ –∫—Ä—É–≥–ª—ã–π –¥–ª—è –∫–Ω–æ–ø–æ–∫ */
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    align-items: center;
}

/* –ö–Ω–æ–ø–∫–∏ –≤–Ω—É—Ç—Ä–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ */
.icon-btn {
    width: 36px; /* –ß—É—Ç—å –∫–æ–º–ø–∞–∫—Ç–Ω–µ–µ */
    height: 36px; 
    border-radius: 50%; 
    background: transparent; /* –§–æ–Ω —Ç–µ–ø–µ—Ä—å –æ–±—â–∏–π —É –ø–∞–Ω–µ–ª–∏ */
    border: none;
    display: flex; 
    align-items: center; 
    justify-content: center;
    font-size: 18px; 
    box-shadow: none; /* –¢–µ–Ω—å —Ç–µ–ø–µ—Ä—å —É –æ–±—â–µ–π –ø–∞–Ω–µ–ª–∏ */
}

.icon-btn:active { 
    transform: scale(0.9); 
    background: #f3f4f6; 
}

/* –ê–∫—Ç–∏–≤–Ω–∞—è –ª–∏–Ω–µ–π–∫–∞ */
.icon-btn.active-tool {
    background: #ec4899;
    color: white;
    box-shadow: 0 2px 5px rgba(236, 72, 153, 0.4);
}

/* COMPARE OVERLAY */
#compare-overlay {
  display: none; 
  position: absolute; 
  top: 70px;
  left: 10px; 
  background: rgba(255, 255, 255, 0.95);
  padding: 12px; 
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
  border-left: 4px solid var(--primary);
  max-width: 300px; 
  font-size: 11px; 
  color: #333; 
  pointer-events: auto; /* –í–ê–ñ–ù–û: auto, —á—Ç–æ–±—ã —Ä–∞–±–æ—Ç–∞–ª–∞ –∫–Ω–æ–ø–∫–∞ */
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* –ê–Ω–∏–º–∞—Ü–∏—è */
  overflow: hidden;
}

/* –°–¢–ò–õ–ò –°–í–ï–†–ù–£–¢–û–ì–û –°–û–°–¢–û–Ø–ù–ò–Ø */
#compare-overlay.minimized {
  width: 44px !important;      /* –£–∑–∫–∞—è –ø–æ–ª–æ—Å–∫–∞ */
  max-height: 160px;
  padding: 8px 4px;
  cursor: pointer;
  background: rgba(255, 255, 255, 0.8);
}

#compare-overlay.minimized .cmp-header, 
#compare-overlay.minimized .cmp-content {
  opacity: 0;            /* –°–∫—Ä—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç */
  pointer-events: none;
  display: none;         /* –£–±–∏—Ä–∞–µ–º –∏–∑ –ø–æ—Ç–æ–∫–∞ */
}

#compare-overlay.minimized .cmp-title {
  writing-mode: vertical-rl; /* –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç */
  text-orientation: mixed;
  transform: rotate(180deg); /* –†–∞–∑–≤–æ—Ä–æ—Ç, —á—Ç–æ–±—ã —á–∏—Ç–∞–ª–æ—Å—å —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö */
  white-space: nowrap;
  margin: 30px auto 0;       /* –û—Ç—Å—Ç—É–ø —Å–≤–µ—Ä—Ö—É –ø–æ–¥ –∫–Ω–æ–ø–∫—É */
  text-align: center;
  width: 100%;
}

/* –ö–ù–û–ü–ö–ê –°–í–û–†–ê–ß–ò–í–ê–ù–ò–Ø */
.cmp-toggle-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 24px;
  height: 24px;
  background: transparent;
  border: none;
  color: var(--primary);
  font-weight: 800;
  font-size: 18px;
  line-height: 1;
  cursor: pointer;
  z-index: 5;
  display: flex;
  align-items: center;
  justify-content: center;
}

#compare-overlay.minimized .cmp-toggle-btn {
  right: 50%;
  transform: translateX(50%); /* –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É –≤ —É–∑–∫–æ–π –ø–æ–ª–æ—Å–∫–µ */
}

.cmp-title { font-weight: 700; font-size: 13px; margin-bottom: 8px; color: var(--primary); }
.cmp-header { font-weight: 700; border-bottom: 1px solid #ddd; padding-bottom: 4px; margin-bottom: 4px; display:grid; grid-template-columns: 1fr 1fr; gap:10px; text-align:center;}
.cmp-tier { padding: 4px; background: #f9f9f9; border-radius: 4px; margin-bottom: 4px; }

/* BOTTOM SHEET */
/* --- –ù–û–í–ê–Ø –®–¢–û–†–ö–ê (GLASSMORPHISM + DRAG) --- */
.bottom-sheet {
  position: absolute; bottom: 0; left: 0; width: 100%;
  height: 40vh; /* –ù–∞—á–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ */
  min-height: 15vh; max-height: 95vh;
  background: rgba(255, 255, 255, 0.9); /* –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å */
  backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
  border-radius: 24px 24px 0 0;
  box-shadow: 0 -5px 30px rgba(0,0,0,0.15);
  border-top: 1px solid rgba(255,255,255,0.5);
  display: flex; flex-direction: column; 
  pointer-events: auto; z-index: 20;
  transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  will-change: height, transform;
}
/* –ö–ª–∞—Å—Å –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è —à—Ç–æ—Ä–∫–∏ –≤–Ω–∏–∑ */
.bottom-sheet.hidden-sheet { transform: translateY(110%); }

/* –†—É—á–∫–∞ –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è */
.sheet-handle-area {
  width: 100%; padding: 12px 0 8px 0;
  display: flex; justify-content: center; align-items: center;
  cursor: grab; touch-action: none; flex-shrink: 0;
}
.sheet-handle-bar {
  width: 40px; height: 5px; background: #ccc; border-radius: 10px;
}

.sheet-header { 
  padding: 0 16px 10px 16px; 
  border-bottom: 1px solid rgba(0,0,0,0.05); 
  display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; 
}
.sheet-title { font-weight: 700; font-size: 16px; }
.sheet-content { 
  padding: 16px; overflow-y: auto; overflow-x: hidden; 
  flex: 1; padding-bottom: 80px; 
}
.back-btn { 
  background: rgba(0,0,0,0.05); border: none; border-radius: 8px; 
  padding: 6px 12px; font-weight: 600; font-size: 13px; color: #333; 
}

/* --- –°–ï–¢–ö–ê 2x2 –î–õ–Ø –ü–ê–†–ê–ú–ï–¢–†–û–í --- */
.control-grid-2 {
  display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;
}
.control-grid-2 .control-group { margin-bottom: 0 !important; }
.control-grid-2 .control-label { 
  font-size: 10px !important; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
}

/* CONTROLS */
.control-group { margin-bottom: 16px; }
.control-label { font-size: 11px; text-transform: uppercase; color: #888; font-weight: 700; margin-bottom: 6px; letter-spacing: px; }
.btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.btn-full { width: 100%; padding: 12px; background: var(--primary); color: white; border: none; border-radius: 10px; font-weight: 600; font-size: 14px; margin-bottom: 8px; }
.btn-sec { background: #fff; border: 1px solid #ddd; color: #333; padding: 10px; border-radius: 10px; font-weight: 600; width: 100%; text-align: left;}
.stepper { display: flex; align-items: center; width: 100%; height: 44px; gap: 6px; }
.stepper button { width: 44px; height: 44px; border-radius: 10px; border: 1px solid #ddd; background: #fff; font-size: 18px; color: var(--primary); font-weight: bold; cursor: pointer; }
.stepper button:active { background: var(--primary); color: #fff; }
.stepper input { flex: 1; height: 44px; text-align: center; border: 1px solid #ddd; border-radius: 10px; font-size: 16px; font-weight: 600; -moz-appearance: textfield; background: #fff;}
.palette { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 8px; }
.swatch { width: 44px; height: 44px; border-radius: 50%; flex-shrink: 0; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
select.btn-sec { -webkit-appearance: none; background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23333%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4l128-128c3.6-3.6%205.4-7.8%205.4-12.8%200-5-1.8-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E"); background-repeat: no-repeat; background-position: right 12px center; background-size: 10px; padding-right: 30px; }

/* TABS & SUMMARY */
.tab-switch { display: flex; background: #f3f4f6; border-radius: 12px; padding: 4px; margin-bottom: 16px; }
.tab-btn { flex: 1; border: none; background: none; padding: 8px; border-radius: 8px; font-weight: 600; color: #666; font-size: 13px; }
.tab-btn.active { background: #fff; color: var(--primary); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
.tier-summary-box { background: #fff0f5; padding: 10px; border-radius: 8px; border: 1px solid #fecdd3; margin-bottom: 16px; font-size: 12px; color: #831843; line-height: 1.5; }
input[type=checkbox] { width: 20px; height: 20px; accent-color: var(--primary); }

/* BOTTOM TOOLBAR */
.toolbar {
  height: calc(var(--toolbar-h) + var(--safe-area-bottom)); background: var(--bg-ui);
  border-top: 1px solid rgba(0,0,0,0.05); display: flex; justify-content: space-around; align-items: flex-start;
  padding-top: 8px; padding-bottom: var(--safe-area-bottom); pointer-events: auto; box-shadow: 0 -4px 20px rgba(0,0,0,0.05);
  transition: transform 0.3s ease;
}
.toolbar.hidden { transform: translateY(100%); }
.nav-item { display: flex; flex-direction: column; align-items: center; gap: 4px; width: 60px; color: #6b7280; font-size: 10px; font-weight: 500; background: none; border: none; padding: 0; }
.nav-icon { font-size: 24px; transition: 0.2s; }
.nav-item.active { color: var(--primary); }


  /* --- –ì–û–†–ò–ó–û–ù–¢–ê–õ–¨–ù–´–ï –ß–ò–ü–°–´ (CHIPS) --- */
.chip-scroll {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding-bottom: 4px; /* –ú–µ—Å—Ç–æ –¥–ª—è —Ç–µ–Ω–∏ */
    margin-bottom: 12px;
    scrollbar-width: none; /* –°–∫—Ä—ã–≤–∞–µ–º —Å–∫—Ä–æ–ª–ª–±–∞—Ä (Firefox) */
    -ms-overflow-style: none; /* –°–∫—Ä—ã–≤–∞–µ–º —Å–∫—Ä–æ–ª–ª–±–∞—Ä (IE/Edge) */
    
    /* –ò–Ω–µ—Ä—Ü–∏—è —Å–∫—Ä–æ–ª–ª–∞ –¥–ª—è iOS - —á—Ç–æ–±—ã –ª–µ—Ç–∞–ª–æ –ø–ª–∞–≤–Ω–æ */
    -webkit-overflow-scrolling: touch; 
}
/* –°–∫—Ä—ã–≤–∞–µ–º —Å–∫—Ä–æ–ª–ª–±–∞—Ä (Chrome/Safari) */
.chip-scroll::-webkit-scrollbar {
    display: none;
}

.chip-btn {
    flex-shrink: 0; /* –ù–µ —Å–∂–∏–º–∞—Ç—å –∫–Ω–æ–ø–∫–∏ */
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 20px; /* –û–≤–∞–ª—å–Ω–∞—è —Ñ–æ—Ä–º–∞ */
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 600;
    color: #333;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s ease;
}

/* –ê–∫—Ç–∏–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ */
.chip-btn.active {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
    box-shadow: 0 2px 8px rgba(236, 72, 153, 0.4);
}

/* –ù–∞–∂–∞—Ç–∏–µ */
.chip-btn:active {
    transform: scale(0.95);
}

@media (orientation: landscape) {
  #ui-layer { flex-direction: row; }
  .toolbar { width: 70px; height: 100%; flex-direction: column; justify-content: center; border-top: none; border-left: 1px solid #eee; order: 2; padding: 0; }
  .toolbar.hidden { transform: translateX(100%); }
  .bottom-sheet { left: auto; right: 0; bottom: 0; top: 0; width: 320px; height: 100%; max-height: 100%; border-radius: 0; border-left: 1px solid #eee; transform: translateX(110%); }
  .bottom-sheet.open { transform: translateX(0); }
  .top-bar { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: auto; }
  .top-tools { top: 10px; right: 80px; }
  #compare-overlay { left: 20px; top: 60px; }
}
/* --- –ú–û–ë–ò–õ–¨–ù–ê–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø (–ö—Ä—É–ø–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ —Å–Ω–∏–∑—É) --- */
    @media (max-width: 800px) {
        /* 1. –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ –∏ –ø–æ–ª–µ–π –≤–Ω—É—Ç—Ä–∏ –∫–Ω–æ–ø–æ–∫ */
        .btn-sec, .btn-full, select, input[type=text], input[type=number] {
            font-size: 16px !important;       /* –ö—Ä—É–ø–Ω—ã–π —à—Ä–∏—Ñ—Ç */
            padding: 12px 8px !important;     /* –ë–æ–ª—å—à–µ –º–µ—Å—Ç–∞ –¥–ª—è –ø–∞–ª—å—Ü–∞ */
            min-height: 48px !important;      /* –°—Ç–∞–Ω–¥–∞—Ä—Ç Apple –¥–ª—è —Ç–∞—á-—ç–∫—Ä–∞–Ω–æ–≤ */
        }
        
        /* 2. –î–µ–ª–∞–µ–º –∫–Ω–æ–ø–∫–∏ +/- (–≤ —Å—Ç–µ–ø–ø–µ—Ä–∞—Ö) –æ–≥—Ä–æ–º–Ω—ã–º–∏ –∏ —É–¥–æ–±–Ω—ã–º–∏ */
        .stepper button {
            width: 50px !important;           /* –®–∏—Ä–æ–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –º–∏–Ω—É—Å/–ø–ª—é—Å */
            font-size: 22px !important;       /* –ö—Ä—É–ø–Ω—ã–π –∑–Ω–∞–∫ */
        }

        

        
        /* 3. –ß—É—Ç—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ø–æ–ª–µ–π */
        .control-label {
            font-size: 14px !important;
            margin-bottom: 6px !important;
            color: #333;
        }

        /* 4. –ö–û–ú–ü–ê–ö–¢–ù–û–°–¢–¨: –ß—Ç–æ–±—ã –±–æ–ª—å—à–∏–µ –∫–Ω–æ–ø–∫–∏ –≤–ª–µ–∑–ª–∏ –≤ —Ç–æ—Ç –∂–µ —ç–∫—Ä–∞–Ω */
        /* –£–º–µ–Ω—å—à–∞–µ–º –ø—É—Å—Ç—ã–µ –æ—Ç—Å—Ç—É–ø—ã –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ */
        .control-group {
            margin-bottom: 12px !important;   /* –ú–µ–Ω—å—à–µ –¥—ã—Ä–æ–∫ –º–µ–∂–¥—É –±–ª–æ–∫–∞–º–∏ */
        }
        
        /* –£–º–µ–Ω—å—à–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã –≤ —Å–∞–º–æ–º –º–µ–Ω—é */
        #sheet-content {
            padding: 16px !important;
            padding-bottom: 40px !important; /* –û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –¥–ª—è —Å–∫—Ä–æ–ª–ª–∞ */
        }

        /* –î–µ–ª–∞–µ–º —Å–µ—Ç–∫—É –∫–Ω–æ–ø–æ–∫ –ø–ª–æ—Ç–Ω–µ–µ */
        .btn-grid {
            gap: 8px !important;
        }

        /* –¶–≤–µ—Ç–æ–≤—ã–µ –∫—Ä—É–∂–∫–∏ –¥–µ–ª–∞–µ–º –∫—Ä—É–ø–Ω–µ–µ */
        .swatch {
            width: 40px !important;
            height: 40px !important;
        }
    }
    /* –ú–µ—Ç–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ (–ø–ª–∞–≤–∞–µ—Ç –ø–æ–≤–µ—Ä—Ö 3D) */
/* –ú–µ—Ç–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ (–ø–ª–∞–≤–∞–µ—Ç –ø–æ–≤–µ—Ä—Ö 3D) */
.measurement-label {
    position: absolute;
    background: rgba(0, 0, 0, 0.85); /* –ü–æ—á—Ç–∏ —á–µ—Ä–Ω—ã–π —Ñ–æ–Ω */
    color: #ffffff;
    
    /* –ö—Ä—É–ø–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è —á—Ç–µ–Ω–∏—è –Ω–∞ —Ö–æ–¥—É */
    font-size: 24px; 
    font-weight: 800; /* –û—á–µ–Ω—å –∂–∏—Ä–Ω—ã–π —à—Ä–∏—Ñ—Ç */
    font-family: 'Inter', sans-serif;
    
    /* –û—Ç—Å—Ç—É–ø—ã, —á—Ç–æ–±—ã —Ü–∏—Ñ—Ä–∞–º –±—ã–ª–æ –Ω–µ —Ç–µ—Å–Ω–æ */
    padding: 10px 18px;
    border-radius: 50px; /* –û–≤–∞–ª—å–Ω–∞—è —Ñ–æ—Ä–º–∞ */
    
    /* –ë–µ–ª–∞—è –æ–±–≤–æ–¥–∫–∞ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞, –µ—Å–ª–∏ —Ñ–æ–Ω —Ç–æ—Ä—Ç–∞ —Ç–µ–º–Ω—ã–π */
    border: 2px solid #ffffff; 
    box-shadow: 0 4px 15px rgba(0,0,0,); /* –ì–ª—É–±–æ–∫–∞—è —Ç–µ–Ω—å */
    
    pointer-events: none; /* –ü—Ä–æ–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–∫–∏ */
    transform: translate(-50%, -50%);
    display: none;
    z-index: 9999; /* –ì–ê–†–ê–ù–¢–ò–†–û–í–ê–ù–ù–û –ü–û–í–ï–†–• –í–°–ï–ì–û (–¥–∞–∂–µ –º–µ–Ω—é) */
    white-space: nowrap; /* –¢–µ–∫—Å—Ç –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É */
}
.icon-btn.active-tool {
    background: #ec4899;
    color: white;
    border-color: #ec4899;
}
/* –ú–µ—Ç–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤–æ–∑–ª–µ –ø–∞–ª—å—Ü–∞ */
.drag-tooltip {
    position: absolute;
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: bold;
    pointer-events: none;
    z-index: 1000;
    display: none;
    white-space: nowrap;
    transform: translate(-50%, -150%); /* –ß—Ç–æ–±—ã –ø–∞–ª–µ—Ü –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–ª —Ü–∏—Ñ—Ä—ã */
}


  /* --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –î–õ–Ø –°–ï–¢–ö–ò –ù–ê –¢–ï–õ–ï–§–û–ù–ê–• (FINAL) --- */
@media (max-width: 800px) {
    /* 1. –°–∂–∏–º–∞–µ–º —Å–µ—Ç–∫—É */
    .control-grid-2 {
        gap: 8px !important; /* –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –∫–æ–ª–æ–Ω–∫–∞–º–∏ */
    }

    /* 2. –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ —É–º–µ–Ω—å—à–∞–µ–º –∫–Ω–æ–ø–∫–∏ +/- */
    .control-grid-2 .stepper button {
        width: 30px !important;       /* –£–∑–∫–∏–µ –∫–Ω–æ–ø–∫–∏ */
        min-width: 30px !important;   /* –ó–∞–ø—Ä–µ—â–∞–µ–º —Ä–∞—Å—à–∏—Ä—è—Ç—å—Å—è */
        height: 30px !important;      
        min-height: 30px !important;  /* –°–ë–†–û–° –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∏–ª—è */
        font-size: 18px !important;
        padding: 0 !important;        /* –£–±–∏—Ä–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –æ—Ç—Å—Ç—É–ø—ã */
        line-height: 1 !important;    /* –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–ª—é—Å/–º–∏–Ω—É—Å */
    }
    
    /* 3. –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ —É–º–µ–Ω—å—à–∞–µ–º –ø–æ–ª–µ –≤–≤–æ–¥–∞ */
    .control-grid-2 .stepper input {
        width: 100% !important;       /* –†–∞—Å—Ç—è–≥–∏–≤–∞–µ–º, –Ω–æ... */
        min-width: 0 !important;      /* ...—Ä–∞–∑—Ä–µ—à–∞–µ–º —Å–∂–∏–º–∞—Ç—å—Å—è, –µ—Å–ª–∏ —Ç–µ—Å–Ω–æ */
        height: 30px !important;
        min-height: 30px !important;  /* –í–ê–ñ–ù–û: –°–ë–†–û–° –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∏–ª—è 48px */
        font-size: 13px !important;
        padding: 0 2px !important;    /* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã –≤–Ω—É—Ç—Ä–∏ */
    }
    
    /* 4. –ü–æ–¥–∂–∏–º–∞–µ–º —Å–∞–º—É —Å—Ç—Ä–æ–∫—É —Å—Ç–µ–ø–ø–µ—Ä–∞ */
    .control-grid-2 .stepper {
        height: 30px !important;      /* –û–±—â–∞—è –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ */
        min-height: 30px !important;
        gap: 4px !important;          /* –ó–∞–∑–æ—Ä –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–æ–π –∏ –ø–æ–ª–µ–º */
    }

    /* 5. –£–º–µ–Ω—å—à–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫, —á—Ç–æ–±—ã –Ω–µ –∑–∞–Ω–∏–º–∞–ª –º–Ω–æ–≥–æ –º–µ—Å—Ç–∞ */
    .control-grid-2 .control-label {
        font-size: 10px !important;
        margin-bottom: 2px !important;
    }
    
    /* 6. –£–º–µ–Ω—å—à–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã –≤–æ–∫—Ä—É–≥ —Å–∞–º–æ–π —Å–µ—Ç–∫–∏ */
    .control-grid-2 .control-group {
        margin-bottom: 0 !important;
    }
}

  
</style>
</head>
<body>

<div id="app">
  <div id="viewer"><div id="three-container" style="width:100%; height:100%"></div></div>
  <div id="ui-layer">
    <div id="drag-tooltip" class="drag-tooltip">X:0 Y:0</div>
     <div id="measure-label" class="measurement-label">0 mm</div>
    <div id="compare-overlay">
     
       <button class="cmp-toggle-btn" onclick="toggleCompare(event)">‚Äì</button>
       
       <div class="cmp-title" onclick="if(isCompareMinimized) toggleCompare(event)">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ç–æ—Ä—Ç–æ–≤</div>
       
       <div class="cmp-header"><div>–¢–æ—Ä—Ç –ê</div><div>–¢–æ—Ä—Ç –ë</div></div>
       <div class="cmp-content" id="cmp-content" style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;"></div>
    </div>

    <div class="pointer-events-auto" style="position:relative; width:100%; height: 0;">
      <div class="top-bar">
        
        <div class="cake-selector">
          <button class="seg-btn active" id="seg-0" onclick="switchCake(0)">A</button>
          <button class="seg-btn" id="seg-1" onclick="switchCake(1)">B</button>
          <button class="seg-btn" id="seg-both" onclick="switchCake('both')">A+B</button>
        </div>

        <div class="top-tools">
           <button class="icon-btn" id="btn-ruler" onclick="toggleRuler()">üìè</button>
           <button class="icon-btn" onclick="undo()">‚Ü©</button>
           <button class="icon-btn" onclick="redo()">‚Ü™</button>
        </div>

      </div>
    </div>

    <div id="bottom-sheet" class="bottom-sheet hidden-sheet">
   <div class="sheet-handle-area" id="sheet-drag-handle">
       <div class="sheet-handle-bar"></div>
   </div>
   
   <div class="sheet-header">
     <div class="sheet-title" id="sheet-title">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>
     <button class="back-btn" onclick="closeSheet()">–ó–∞–∫—Ä—ã—Ç—å</button>
   </div>
   <div class="sheet-content" id="sheet-content"></div>
</div>

    <div class="toolbar" id="main-toolbar">
      <button class="nav-item" onclick="openMenu('structure')"><span class="nav-icon">üèó</span><span>–§–æ—Ä–º–∞</span></button>
      <button class="nav-item" onclick="openMenu('color')"><span class="nav-icon">üé®</span><span>–¶–≤–µ—Ç</span></button>
      <button class="nav-item" onclick="openMenu('decor')"><span class="nav-icon">‚ú®</span><span>–î–µ–∫–æ—Ä</span></button>
      <button class="nav-item" onclick="openMenu('scene')"><span class="nav-icon">üì∑</span><span>–í–∏–¥</span></button>
      <button class="nav-item" onclick="openMenu('project')"><span class="nav-icon">üíæ</span><span>–§–∞–π–ª</span></button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/USDZExporter.js"></script>

<script>
/* --- 1. CORE & INIT --- */
let scene, camera, renderer, controls, group, raycaster, mouse;
let tapStartX = 0, tapStartY = 0; // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –º–µ—Å—Ç–æ –∫–∞—Å–∞–Ω–∏—è
// --- –ü–ï–†–ï–ú–ï–ù–ù–´–ï –î–õ–Ø –ú–ê–ì–ù–ò–¢–ê ---
let snapLines = { x: null, z: null, y: null }; // –•—Ä–∞–Ω–∏–º –ª–∏–Ω–∏–∏
let isSnapped = { x: false, z: false }; // –ß—Ç–æ–±—ã –Ω–µ –≤–∏–±—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ
const SNAP_DIST_3D = 8; // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –ø—Ä–∏–ª–∏–ø–∞–Ω–∏—è –≤ –º–º (–¥–ª—è 3D)
const SNAP_DIST_SIDE = 0.03; // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –¥–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤ (0.0-1.0)
let isDragging = false, dragData = null;
let cakes = [[], []]; 
let activeCakeId = 0; let viewMode = 'single';
// --- STATE –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
let ui = { selTier: null, selDecorIdx: null, activeMenu: null, colorTab: 'solid', activeTexPart: 'side', lockAspect: true };
// –ù–û–í–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï –î–õ–Ø –ú–£–õ–¨–¢–ò-–í–´–ë–û–†–ê:
let isMultiSelect = false;
let selectedDecors = []; // –ú–∞—Å—Å–∏–≤ –∏–Ω–¥–µ–∫—Å–æ–≤ [0, 2, 5]
let history = [], historyPtr = -1;
let cakeGap = 220; // <--- –î–û–ë–ê–í–ò–¢–¨ –í–û–¢ –≠–¢–£ –ü–ï–†–ï–ú–ï–ù–ù–£–Æ (–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ)
const texLoader = new THREE.TextureLoader();
const STORAGE_KEY = 'cake_mobile_autosave_v2';
const defaultTex = () => ({ url:null, mode:'tile', scale:1, repX:1, repY:1, offX:0, offY:0, rot:0, mixColor:false });
/* --- FONTS CONFIG --- */

/* --- FONTS CONFIG --- */
/* --- FONTS CONFIG --- */
const GFONTS = [
    
    // --- –ë–ê–ó–û–í–´–ï ---
    {n:'Inter', f:'Inter'},
    {n:'Roboto', f:'Roboto'},
    {n:'Playfair', f:'"Playfair Display"'},
    {n:'Oswald', f:'Oswald'}
];


// –§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ —à—Ä–∏—Ñ—Ç–∞ (–•–ê–ö –°–û SPAN)
function loadFont(f) {
    if(!f) return;
    const cf = f.replace(/['"]/g, ""); // –£–±–∏—Ä–∞–µ–º –∫–∞–≤—ã—á–∫–∏ –¥–ª—è URL
    
    // 1. –î–æ–±–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É CSS
    const l = document.createElement('link');
    l.href = "https://fonts.googleapis.com/css?family=' + cf.replace(/ /g, '+') + '&display=swap";
    l.rel = 'stylesheet';
    document.head.appendChild(l);

    // 2. –°–æ–∑–¥–∞–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å —ç—Ç–∏–º —à—Ä–∏—Ñ—Ç–æ–º, —á—Ç–æ–±—ã –±—Ä–∞—É–∑–µ—Ä –Ω–∞—á–∞–ª —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥
    const t = document.createElement('span');
    t.style.fontFamily = f; 
    t.style.opacity = '0'; 
    t.style.position = 'absolute';
    t.style.top = '-9999px';
    t.textContent = 'font_test';
    document.body.appendChild(t); 
    
    // –£–¥–∞–ª—è–µ–º –º—É—Å–æ—Ä —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
    setTimeout(() => { if(t.parentNode) document.body.removeChild(t); }, 2000);
}

// –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö —à—Ä–∏—Ñ—Ç–æ–≤ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
function preloadAllFonts() {
    GFONTS.forEach(font => loadFont(font.f));
}

function init() {
  preloadAllFonts(); // <--- –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
  const el = document.getElementById('three-container');
  scene = new THREE.Scene(); 
  scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // –î–µ–ª–∞–µ–º —Å—Ü–µ–Ω—É —Å–≤–µ—Ç–ª–µ–µ
  const dl = new THREE.DirectionalLight(0xffffff, 0.8); 
  dl.position.set(300, 700, 300); // –°–≤–µ—Ä—Ö—É —Å–ø—Ä–∞–≤–∞
  dl.castShadow = true;
  dl.shadow.camera.left = -1000;
  dl.shadow.camera.right = 1000;
  dl.shadow.camera.top = 1000;
  dl.shadow.camera.near = 10;
  dl.shadow.camera.far = 3000;
  dl.shadow.camera.bottom = -1000;
  dl.shadow.mapSize.width = 2048;
  dl.shadow.mapSize.height = 2048;
  dl.shadow.bias = -0.001;
  scene.add(dl);
  
  camera = new THREE.PerspectiveCamera(45, el.clientWidth/el.clientHeight, 1, 8000); 
  camera.position.set(0, 400, 700); 
  
  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true, preserveDrawingBuffer:true});
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
  renderer.shadowMap.autoUpdate = false; // –ó–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ–º —Ç–µ–Ω–∏
  renderer.setSize(el.clientWidth, el.clientHeight); 
  renderer.outputEncoding = THREE.sRGBEncoding; 
  renderer.setPixelRatio(window.devicePixelRatio);
  el.appendChild(renderer.domElement);
  
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  
  // –†–ê–ó–†–ï–®–ê–ï–ú –°–î–í–ò–ì
  controls.enablePan = true;
  controls.screenSpacePanning = true; // <--- –í–ê–ñ–ù–û: –°–¥–≤–∏–≥ –±—É–¥–µ—Ç –∫–∞–∫ –Ω–∞ 2D —Ö–æ–ª—Å—Ç–µ (–≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑-–≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ)

  // –ù–ê–°–¢–†–û–ô–ö–ê –ñ–ï–°–¢–û–í
  controls.touches = {
      ONE: THREE.TOUCH.ROTATE,      // 1 –ø–∞–ª–µ—Ü: –í—Ä–∞—â–µ–Ω–∏–µ
      TWO: THREE.TOUCH.DOLLY_PAN    // 2 –ø–∞–ª—å—Ü–∞: –ó—É–º + –°–¥–≤–∏–≥
  };

  controls.minDistance = 150;
  controls.maxDistance = 2000;
  controls.maxPolarAngle = Math.PI / 2;

  // --- –°–ö–û–†–û–°–¢–¨ ---
  // –ï—Å–ª–∏ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ –¥–≤–∏–≥–∞–µ—Ç—Å—è —Å–ª–∏—à–∫–æ–º –º–µ–¥–ª–µ–Ω–Ω–æ, —É–≤–µ–ª–∏—á—å—Ç–µ —ç—Ç–æ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–æ 1.0 –∏–ª–∏ 1.5)
  if (window.innerWidth < 900) {
      controls.panSpeed = 0.7;   // –°–∫–æ—Ä–æ—Å—Ç—å —Å–¥–≤–∏–≥–∞ (–±—ã–ª–æ 0.5, –ø–æ—Å—Ç–∞–≤–∏–ª 1.0 –¥–ª—è —Ä–µ–∑–≤–æ—Å—Ç–∏)
      controls.rotateSpeed = 0.6; // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è
      controls.dampingFactor = 0.07; 
  }
  
  group = new THREE.Group(); scene.add(group);
  raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
  el.addEventListener('pointerdown', onPointerDown); 
  window.addEventListener('resize', onWindowResize);
  
  const saved = localStorage.getItem(STORAGE_KEY);
  let restored = false;
  if (saved) {
      if(confirm('–ù–∞–π–¥–µ–Ω–∞ –Ω–µ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –ø—Ä–æ–µ–∫—Ç–∞. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å?')) {
          try {
              const data = JSON.parse(saved);
              if(data && data.cakes) { cakes = data.cakes; restored = true; }
          } catch(e) { console.error(e); }
      }
  }
  
  if(!restored && cakes[0].length === 0) {
      cakes[0].push({id:Date.now(), shape:'cylinder', d:200, h:100, n:6, w:200, dep:200, color:'#ffffff', weight:2, filling:'–í–∞–Ω–∏–ª—å', tex:{side:defaultTex(), top:defaultTex(), bottom:defaultTex()}, decor:[]});
      ui.selTier = 0;
  }
  
  rebuildScene(); 
  recordHistory(); 
  animate();
  
  setInterval(() => { localStorage.setItem(STORAGE_KEY, JSON.stringify({cakes: cakes, date: Date.now()})); }, 60000);
  setInterval(() => { const name = prompt("–ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ (15 –º–∏–Ω). –í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:", "cake_autosave"); if(name) saveProject(name); }, 900000);


  // –°–æ–∑–¥–∞–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–π –ø–æ–ª –¥–ª—è —Ç–µ–Ω–µ–π
  const floorGeo = new THREE.PlaneGeometry(5000, 5000);
  const floorMat = new THREE.ShadowMaterial({ opacity: 0.15 }); // –õ–æ–≤–∏—Ç —Ç–æ–ª—å–∫–æ —Ç–µ–Ω–∏, —Å–∞–º –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -5; // –ß—É—Ç—å –Ω–∏–∂–µ —Å–∞–º–æ–π –Ω–∏–∂–Ω–µ–π –ø–æ–¥–ª–æ–∂–∫–∏
  floor.receiveShadow = true; // –†–ê–ó–†–ï–®–ê–ï–ú –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ç–µ–Ω–∏
  scene.add(floor);
}

function onWindowResize() {
    const el = document.getElementById('three-container');
    camera.aspect = el.clientWidth / el.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(el.clientWidth, el.clientHeight);
}

function animate() {
    requestAnimationFrame(animate);

    // --- –õ–û–ì–ò–ö–ê "–†–ï–õ–¨–°" (–û–±–Ω–æ–≤–ª–µ–Ω–æ —Å —É—á–µ—Ç–æ–º cakeGap) ---
    if (viewMode === 'single') {
        // –¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é cakeGap, –∞ –Ω–µ 220
        const lockedX = (activeCakeId === 0) ? -cakeGap : cakeGap;
        
        controls.target.x = lockedX; 
        controls.target.z = 0;       
    }

    if (controls.target.y < 0) controls.target.y = 0;
    if (controls.target.y > 1000) controls.target.y = 1000;

    controls.update();
    
    if (rulerMode) updateMeasureLabel();
    renderer.render(scene, camera);
}

/* --- 2. SCENE LOGIC --- */
function fixExtrudedGeometry(geo) {
  geo.computeBoundingBox(); const box=geo.boundingBox; const size=new THREE.Vector3(); box.getSize(size);
  const pos=geo.attributes.position, norm=geo.attributes.normal, uvs=geo.attributes.uv;
  const grpS=[], grpT=[], grpB=[]; const p=new THREE.Vector3(), n=new THREE.Vector3();
  for(let i=0;i<pos.count;i+=3) {
    n.fromBufferAttribute(norm, i);
    if(n.y>0.9) { grpT.push(i,i+1,i+2); for(let k=0;k<3;k++){p.fromBufferAttribute(pos,i+k); uvs.setXY(i+k, (p.x-box.min.x)/size.x, 1-(p.z-box.min.z)/size.z);} } 
    else if(n.y<-0.9) { grpB.push(i,i+1,i+2); for(let k=0;k<3;k++){p.fromBufferAttribute(pos,i+k); uvs.setXY(i+k, (p.x-box.min.x)/size.x, (p.z-box.min.z)/size.z);} } 
    else { grpS.push(i,i+1,i+2); for(let k=0;k<3;k++){p.fromBufferAttribute(pos,i+k); const ang=Math.atan2(p.z,p.x); uvs.setXY(i+k, (ang+Math.PI)/(2*Math.PI), (p.y-box.min.y)/size.y);} }
  }
  const idx=[]; geo.clearGroups();
  geo.addGroup(idx.length, grpS.length, 0); idx.push(...grpS); geo.addGroup(idx.length, grpT.length, 1); idx.push(...grpT);
  geo.addGroup(idx.length, grpB.length, 2); idx.push(...grpB); geo.setIndex(idx); return geo;
}

function createHeartGeo(r, h) {
  const shape = new THREE.Shape(); const x = 0, y = 0;
  shape.moveTo(x + 0.5*r, y + 0.5*r); shape.bezierCurveTo(x + 0.5*r, y + 0.5*r, x + 0.4*r, y, x, y);
  shape.bezierCurveTo(x - 0.6*r, y, x - 0.6*r, y + 0.7*r, x - 0.6*r, y + 0.7*r);
  shape.bezierCurveTo(x - 0.6*r, y + 1.1*r, x - 0.3*r, y + 1.54*r, x + 0.5*r, y + 1.9*r);
  shape.bezierCurveTo(x + 1.2*r, y + 1.54*r, x + 1.6*r, y + 1.1*r, x + 1.6*r, y + 0.7*r);
  shape.bezierCurveTo(x + 1.6*r, y + 0.7*r, x + 1.6*r, y, x + 1.0*r, y); shape.bezierCurveTo(x + 0.7*r, y, x + 0.5*r, y + 0.5*r, x + 0.5*r, y + 0.5*r);
  const geo = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false }); geo.center(); geo.rotateX(Math.PI/2); return geo;
}

function createStarGeo(r, h) {
  const shape = new THREE.Shape(); const points = 5; const startAng = -Math.PI / 2; 
  for (let i = 0; i < points * 2; i++) {
    const ang = startAng + (i / (points * 2)) * Math.PI * 2; const rad = (i % 2 === 0) ? r : r * 0.5; 
    const x = Math.cos(ang) * rad; const y = Math.sin(ang) * rad;
    if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y);
  }
  shape.closePath(); const geo = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });
  geo.center(); geo.rotateX(Math.PI/2); geo.rotateY(Math.PI); return geo;
}

function createLabelTexture(letter) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath(); ctx.arc(64, 64, 55, 0, Math.PI*2); ctx.fill();
    ctx.lineWidth = 6; ctx.strokeStyle = '#ec4899'; ctx.stroke();
    ctx.fillStyle = '#ec4899'; ctx.font = 'bold 80px Inter, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(letter, 64, 68);
    return new THREE.CanvasTexture(canvas);
}

function rebuildScene() {
  while(group.children.length) group.remove(group.children[0]);

  cakes.forEach((tiers, cIdx) => {
    if(viewMode === 'single' && cIdx !== activeCakeId) return;
    
    // <--- –ò–°–ü–†–ê–í–õ–ï–ù–û: –¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é cakeGap, –∞ –Ω–µ 220
    const offsetX = (cIdx === 0) ? -cakeGap : cakeGap; 
    
    const cakeGroup = new THREE.Group(); 
    cakeGroup.position.set(offsetX, 0, 0);
    
    // LABEL A/B (–°–¥–≤–∏–≥–∞–µ–º –±—É–∫–≤—É —Ç–æ–∂–µ)
    const labelTex = createLabelTexture(cIdx === 0 ? 'A' : 'B');
    const labelMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(80, 80), 
      new THREE.MeshBasicMaterial({ map: labelTex, transparent: true, side: THREE.DoubleSide })
    );
    labelMesh.rotation.x = -Math.PI / 2; 
    // –ë—É–∫–≤–∞ –≤–∏—Å–∏—Ç —á—É—Ç—å —Å–ø–µ—Ä–µ–¥–∏ (Z=220 –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –∏–ª–∏ —Ç–æ–∂–µ –ø—Ä–∏–≤—è–∑–∞—Ç—å –∫ —Ä–∞–∑–º–µ—Ä—É, –Ω–æ –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º)
    labelMesh.position.set(0, 0.5, 220); 
    cakeGroup.add(labelMesh);

    let curY = 0;
    tiers.forEach((t, idx) => {
      let geo;
      if(t.shape==='cylinder') geo=new THREE.CylinderGeometry(t.d/2,t.d/2,t.h,32);
      else if(t.shape==='box') geo=new THREE.BoxGeometry(t.d,t.h,t.d);
      else if(t.shape==='parallelepiped') geo=new THREE.BoxGeometry(t.w,t.h,t.dep);
      else if(t.shape==='sphere') geo=new THREE.SphereGeometry(t.d/2,32,16);
      else if(t.shape==='ngon') geo=new THREE.CylinderGeometry(t.d/2,t.d/2,t.h,t.n || 6);
      else if(t.shape==='heart') geo=fixExtrudedGeometry(createHeartGeo(t.d/2, t.h));
      else if(t.shape==='star') geo=fixExtrudedGeometry(createStarGeo(t.d/2, t.h));

      // LAYER 1: BASE MATERIAL
      let baseMat;
      const mType = t.coating || 'cream';
      const matProps = { color: t.color };
      
      if (mType === 'velvet') {
          Object.assign(matProps, { roughness: 0.9, bumpMap: NOISE_TEX, bumpScale: 1.0 });
      } else if (mType === 'mirror') {
          Object.assign(matProps, { roughness: 0.1, metalness: 0.3 });
      } else if (mType === 'mastic') {
          Object.assign(matProps, { roughness: 0.5, metalness: 0.0 });
      } else {
          Object.assign(matProps, { roughness: 0.6, bumpMap: NOISE_TEX, bumpScale: 0.2 });
      }
      baseMat = new THREE.MeshStandardMaterial(matProps);
      
      const baseMesh = new THREE.Mesh(geo, baseMat);
      baseMesh.castShadow = true;
      baseMesh.receiveShadow = true;
      
      const h = (t.shape==='sphere') ? t.d : t.h;
      baseMesh.position.y = h/2; 
      baseMesh.rotation.y = (t.rot || 0) * Math.PI / 180;
      baseMesh.userData = { tIdx:idx, cIdx: cIdx, type:'tier' };
      
      const tGrp = new THREE.Group(); 
      tGrp.add(baseMesh);

      // BOARD
      if (idx === 0 && t.board && t.board.enabled) {
          const b = t.board;
          const off = b.offset || 0;
          const th = b.thickness || 3;
          const forceRound = (b.isRound !== false);
          const matSurface = new THREE.MeshStandardMaterial({ color: b.color, roughness: 0.4, metalness: 0.1 });
          const matEdge = new THREE.MeshStandardMaterial({ color: '#1a1a1a', roughness: 0.8 });
          let bGeo;
          let bMaterials;

          if (forceRound) {
              let r = t.d / 2;
              if (t.shape === 'parallelepiped') r = Math.max(t.w, t.dep) / 2;
              else if (t.shape === 'box') r = (t.d * Math.sqrt(2)) / 2;
              bGeo = new THREE.CylinderGeometry(r + off/2, r + off/2, th,32);
              bMaterials = [matEdge, matSurface, matEdge];
          } else {
              if (t.shape === 'box') bGeo = new THREE.BoxGeometry(t.d + off, th, t.d + off);
              else if (t.shape === 'parallelepiped') bGeo = new THREE.BoxGeometry(t.w + off, th, t.dep + off);
              else if (t.shape === 'heart') bGeo = fixExtrudedGeometry(createHeartGeo((t.d + off)/2, th));
              else if (t.shape === 'star') bGeo = fixExtrudedGeometry(createStarGeo((t.d + off)/2, th));
              else if (t.shape === 'ngon') bGeo = new THREE.CylinderGeometry((t.d + off)/2, (t.d + off)/2, th, t.n || 6);
              else bGeo = new THREE.CylinderGeometry((t.d + off)/2, (t.d + off)/2, th, 32);
              bMaterials = (bGeo.type === 'BoxGeometry') ? [matEdge, matEdge, matSurface, matEdge, matEdge, matEdge] : [matEdge, matSurface, matEdge];
          }
          const bMesh = new THREE.Mesh(bGeo, bMaterials);
          bMesh.receiveShadow = true;
          bMesh.castShadow = true;
          bMesh.position.y = -th / 2;
          bMesh.rotation.y = (t.rot || 0) * Math.PI / 180;
          tGrp.add(bMesh);
      }

      // DRIPS
      if (t.drips && t.drips.enabled) {
          const dripsMesh = createDrips(t.shape, (t.shape==='box')?t.d:(t.shape==='parallelepiped'?t.w:t.d/2), (t.shape==='box')?t.d:t.dep, t.drips.color||'#3e2723', t.drips.len, t.drips.freq);
          dripsMesh.position.y = h; tGrp.add(dripsMesh);
      }

      // TEXTURES
      if (t.tex && (t.tex.side.url || t.tex.top.url || t.tex.bottom.url)) {
          const getTexMat = (p) => {
              const d = t.tex[p];
              if(d && d.url) {
                  const m = texLoader.load(d.url); m.encoding = THREE.sRGBEncoding; const s = d.scale || 1;
                  m.center.set(0.5, 0.5); m.rotation = (d.rot || 0) * Math.PI / 180;
                  if(d.mode === 'fit') { m.wrapS = m.wrapT = THREE.ClampToEdgeWrapping; m.repeat.set(1/s, 1/s); m.offset.set(0.5 - 0.5/s + (d.offX||0), 0.5 - 0.5/s + (d.offY||0)); } 
                  else { m.wrapS = m.wrapT = THREE.RepeatWrapping; m.repeat.set((d.repX||1)/s, (d.repY||1)/s); m.offset.set(d.offX||0, d.offY||0); }
                  return new THREE.MeshStandardMaterial({ color: d.mixColor ? t.color : 0xffffff, map: m, transparent: true, roughness: 0.5, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1 });
              }
              return new THREE.MeshBasicMaterial({visible: false});
          };
          let texMats;
          if(t.shape==='box'||t.shape==='parallelepiped') { const s = getTexMat('side'); texMats = [s, s, getTexMat('top'), getTexMat('bottom'), s, s]; } 
          else if(t.shape==='sphere') { texMats = getTexMat('side'); } 
          else { texMats = [getTexMat('side'), getTexMat('top'), getTexMat('bottom')]; }
          const texMesh = new THREE.Mesh(geo, texMats);
          texMesh.position.copy(baseMesh.position); texMesh.rotation.copy(baseMesh.rotation);
          texMesh.scale.set(1.001, 1.001, 1.001);
          texMesh.userData = { tIdx:idx, cIdx: cIdx, type:'tier' }; tGrp.add(texMesh);
      }
      
      // DECORS
      t.decor.forEach((s, si) => {
          if(!s.url) return;
          const isSel = (ui.selTier === idx && activeCakeId === cIdx) && 
                        ( (ui.selDecorIdx === si && !isMultiSelect) || (isMultiSelect && selectedDecors.includes(si)) );
          let dMesh;
          let tex = null;
          if (s.url !== '3d_prim') {
              tex = texLoader.load(s.url);
          }
          
          const matParams = { 
            map: tex, 
            transparent: true, 
            alphaTest: 0.4,
            color: s.tintColor || '#ffffff' 
          };

          if (s.placement === 'volume') {
              let vGeo;
              if (s.shape === 'sphere') vGeo = new THREE.SphereGeometry(s.w / 2, 24, 24);
              else if (s.shape === 'cube') vGeo = new THREE.BoxGeometry(s.w, s.h, s.w);
              else if (s.shape === 'cylinder') vGeo = new THREE.CylinderGeometry(s.w / 2, s.w / 2, s.h, 24);
              else vGeo = new THREE.BoxGeometry(s.w, s.h, s.w);

              const vMat = new THREE.MeshStandardMaterial({ 
                  color: s.color || 0xffffff, 
                  roughness: 0.4, 
                  metalness: 0.1,
                  flatShading: false 
              });
              
              dMesh = new THREE.Mesh(vGeo, vMat);
              dMesh.castShadow = true;
              dMesh.receiveShadow = true;
              dMesh.position.set(s.x || 0, curY + h + (s.h / 2) + (s.y || 0), s.z || 0);
              dMesh.rotation.order = 'YXZ';
              dMesh.rotation.y = (s.rot || 0) * Math.PI / 180;
              dMesh.rotation.x = (s.rotX || 0) * Math.PI / 180; 
              dMesh.rotation.z = (s.rotZ || 0) * Math.PI / 180;
              
              dMesh.userData = { tIdx:idx, dIdx:si, cIdx:cIdx, type:'decor' };
              if(isSel) dMesh.add(new THREE.BoxHelper(dMesh, 0xec4899));
              tGrp.add(dMesh);
              return; 
          }
          if (s.placement === 'topper') {
              tex.center.set(0.5, 0.5); tex.repeat.set(1, 1);
              const dGeo = new THREE.BoxGeometry(s.w, s.h, 3);
              const uv = dGeo.attributes.uv; const normal = dGeo.attributes.normal;
              for (let i = 0; i < normal.count; i++) {
                  if (normal.getZ(i) < -0.5) uv.setX(i, 1 - uv.getX(i));
              }
              uv.needsUpdate = true; 
              const matTrans = new THREE.MeshBasicMaterial({transparent:true, opacity:0});
              const matFace = new THREE.MeshBasicMaterial({...matParams, map: tex, side: THREE.FrontSide});
              dMesh = new THREE.Mesh(dGeo, [matTrans, matTrans, matTrans, matTrans, matFace, matFace]);
              dMesh.position.set(s.x || 0, curY + h + (s.h/2) - 5 + (s.y || 0), s.z || 0);
              dMesh.rotation.order = 'YXZ'; 
              dMesh.rotation.y = -(s.rot || 0) * Math.PI / 180; 
              dMesh.rotation.x = (s.rotX || 0) * Math.PI / 180; 
              dMesh.rotation.z = (s.rotZ || 0) * Math.PI / 180; 
          }
          else if (s.placement === 'top') {
              dMesh = new THREE.Mesh(new THREE.PlaneGeometry(s.w, s.h), new THREE.MeshBasicMaterial({...matParams, side:THREE.DoubleSide, depthWrite:false, polygonOffset:true, polygonOffsetFactor:-2}));
              dMesh.rotation.x = -Math.PI / 2; dMesh.rotation.z = -(s.rot || 0) * Math.PI / 180;
              dMesh.position.set(s.x || 0, curY + h + 0.2 + (s.y || 0), s.z || 0);
          } else {
              const isBox = (t.shape === 'box' || t.shape === 'parallelepiped');
              const baseRadius = (t.shape==='parallelepiped' ? t.dep : t.d) / 2;
              const depthOffset = baseRadius + 0.6 + (s.z || 0);
              let dGeo;
              if (isBox) {
                  dGeo = new THREE.PlaneGeometry(s.w, s.h);
                  const width = (t.shape === 'box' ? t.d : t.w);
                  const depth = (t.shape === 'box' ? t.d : t.dep);
                  const perimeter = (width + depth) * 2;
                  let dist = (s.x || 0) * perimeter;
                  dMesh = new THREE.Mesh(dGeo, new THREE.MeshBasicMaterial({...matParams, side:THREE.DoubleSide, depthWrite:false, polygonOffset:true, polygonOffsetFactor:-2}));
                  
                  if (dist < width) {
                      dMesh.position.set(dist - width/2, 0, depth/2 + (s.z || 0.6)); dMesh.rotation.y = 0;
                  } else if (dist < width + depth) {
                      dMesh.position.set(width/2 + (s.z || 0.6), 0, depth/2 - (dist - width)); dMesh.rotation.y = Math.PI / 2;
                  } else if (dist < width * 2 + depth) {
                      dMesh.position.set(width/2 - (dist - (width + depth)), 0, -depth/2 - (s.z || 0.6)); dMesh.rotation.y = Math.PI;
                  } else {
                      dMesh.position.set(-width/2 - (s.z || 0.6), 0, -depth/2 + (dist - (width * 2 + depth))); dMesh.rotation.y = -Math.PI / 2;
                  }
              } else {
                  const r = depthOffset; const arcLength = s.w / r;
                  dGeo = new THREE.CylinderGeometry(r, r, s.h, 32, 1, true, -arcLength/2, arcLength);
                  dMesh = new THREE.Mesh(dGeo, new THREE.MeshBasicMaterial({...matParams, side:THREE.DoubleSide, depthWrite:false, polygonOffset:true, polygonOffsetFactor:-2}));
                  dMesh.rotation.y = (s.x || 0) * Math.PI * 2 + Math.PI;
              }
              dMesh.position.y = curY + (s.y!==undefined ? s.y : 0.5) * h;
          }

          dMesh.userData = { tIdx:idx, dIdx:si, cIdx:cIdx, type:'decor' };
          if(isSel) dMesh.add(new THREE.BoxHelper(dMesh, 0xec4899));
          tGrp.add(dMesh);
      });

      // SELECTION HIGHLIGHT
      if(ui.selTier===idx && activeCakeId === cIdx) { 
          const isSmooth = ['sphere','cylinder','ngon'].includes(t.shape);
          const selGeo = isSmooth ? geo : new THREE.EdgesGeometry(geo);
          const selMat = isSmooth ? new THREE.MeshBasicMaterial({color:0xec4899, wireframe:true, transparent:true, opacity:0.1}) : new THREE.LineBasicMaterial({color:0xec4899});
          const sel = isSmooth ? new THREE.Mesh(selGeo, selMat) : new THREE.LineSegments(selGeo, selMat);
          sel.position.y = h/2; sel.rotation.y = baseMesh.rotation.y; 
          if(isSmooth) sel.scale.set(1.03, 1.03, 1.03); tGrp.add(sel);
      }

      // INFO LABELS
      const infoLabel = createInfoSprite(t);
      const dir = (cIdx === 0) ? -1 : 1;
      let rMax = t.d/2;
      if(t.shape==='box') rMax = (t.d * Math.sqrt(2))/2;
      if(t.shape==='parallelepiped') rMax = Math.max(t.w, t.dep)/2;
      infoLabel.position.set(dir * (rMax + 160), h/2, 0);
      tGrp.add(infoLabel);
      
      tGrp.position.y = curY;
      cakeGroup.add(tGrp); 
      curY += h;
    });
    group.add(cakeGroup);
  });
}

/* --- 3. UI GENERATION --- */
function openMenu(menuName, scrollTarget) {

  if(menuName !== ui.activeMenu) vibro('light');
    // --- 1. –ó–ê–ü–û–ú–ò–ù–ê–ï–ú –¢–ï–ö–£–©–ò–ô –°–ö–†–û–õ–õ ---
    let savedScroll = 0;
    let wasDecorListOpen = false;
    const oldList = document.getElementById('decor-list-box');
    
    if (oldList) {
        savedScroll = oldList.scrollTop;
        wasDecorListOpen = true;
    }

    ui.activeMenu = menuName;
    const sheet = document.getElementById('bottom-sheet');
    const content = document.getElementById('sheet-content');
    const title = document.getElementById('sheet-title');
    
    // !!! –ì–õ–ê–í–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û—Ç–∫—Ä—ã–≤–∞–µ–º —à—Ç–æ—Ä–∫—É (—É–±–∏—Ä–∞–µ–º –∫–ª–∞—Å—Å —Å–∫—Ä—ã—Ç–∏—è) !!!
    sheet.classList.remove('hidden-sheet');

    let html = '';
  
    // –õ–æ–≥–∏–∫–∞ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    if (menuName === 'structure' && ui.selTier !== null) {
        menuName = 'structure_edit';
    }

    // --- –ú–ï–ù–Æ: –°–¢–†–£–ö–¢–£–†–ê (–°–ü–ò–°–û–ö) ---
    if (menuName === 'structure') {
        title.innerHTML = 'üèó –°—Ç—Ä—É–∫—Ç—É—Ä–∞';
        html += `<button class="btn-full" onclick="actionAddTier()">+ –î–æ–±–∞–≤–∏—Ç—å –Ø—Ä—É—Å</button>`;
        const targetName = (activeCakeId === 0) ? 'B' : 'A';
        html += `<button class="btn-sec" style="margin-top:10px; width:100%" onclick="copyCakeToOther()">üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –¢–æ—Ä—Ç ${targetName}</button>`;
        
        if(getActiveTiers().length > 0) {
             html += `<div class="control-label" style="margin-top:16px">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —è—Ä—É—Å:</div>`;
             getActiveTiers().forEach((t, i) => {
                 html += `<button class="btn-sec" style="margin-bottom:6px" onclick="selectAndEditTier(${i})">–Ø—Ä—É—Å ${i+1} (${getShapeName(t.shape)})</button>`;
             });
        }

    // --- –ú–ï–ù–Æ: –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–ï –Ø–†–£–°–ê (–°–ï–¢–ö–ê 2x2) ---
    } else if (menuName === 'structure_edit') {
        const tiers = getActiveTiers();
        if (ui.selTier === null || !tiers[ui.selTier]) {
            openMenu('structure');
            return;
        }
        
        const t = tiers[ui.selTier];
        title.innerHTML = `–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ø—Ä—É—Å–∞ ${ui.selTier+1}`;
        
        const dimStr = (t.shape==='box') ? `${t.d/10}x${t.d/10}` : (t.shape==='parallelepiped' ? `${t.w/10}x${t.dep/10}` : `√ò${t.d/10}`);
        const hStr = (t.shape==='sphere') ? `${t.d/10}` : `${t.h/10}`;
        
        html += `<div class="tier-summary-box"><strong>–ò–Ω—Ñ–æ:</strong> ${dimStr} —Å–º | h ${hStr} —Å–º<br>‚öñÔ∏è ${t.weight || 0} –∫–≥ | üéÇ ${t.filling || '–ù–µ—Ç'}</div>`;

        // –ö–Ω–æ–ø–∫–∏ –í–≤–µ—Ä—Ö/–í–Ω–∏–∑
        html += `<div class="control-group"><div class="btn-grid"><button class="btn-sec" onclick="moveTier(1)">‚ñ≤ –í–≤–µ—Ä—Ö</button><button class="btn-sec" onclick="moveTier(-1)">‚ñº –í–Ω–∏–∑</button></div></div>`;
        
        // –í—ã–±–æ—Ä —Ñ–æ—Ä–º—ã
        // --- –ó–ê–ú–ï–ù–ê SELECT –ù–ê CHIPS (–í—Å—Ç–∞–≤–ª—è–µ–º —Å—é–¥–∞) ---
        const shapes = [
            {val:'cylinder', label:'–¶–∏–ª–∏–Ω–¥—Ä', icon:'‚ö™'},
            {val:'box', label:'–ö—É–±', icon:'üì¶'},
            {val:'parallelepiped', label:'–ü—Ä—è–º–æ—É–≥.', icon:'‚ñ≠'},
            {val:'sphere', label:'–®–∞—Ä', icon:'üîÆ'},
            {val:'heart', label:'–°–µ—Ä–¥—Ü–µ', icon:'‚ù§Ô∏è'},
            {val:'star', label:'–ó–≤–µ–∑–¥–∞', icon:'‚≠ê'},
            {val:'ngon', label:'–ú–Ω–æ–≥–æ—É–≥.', icon:'üî∑'}
        ];

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ª–µ–Ω—Ç—É:
        html += mkSelector('–§–æ—Ä–º–∞ —è—Ä—É—Å–∞', t.shape, shapes, "updateTierProp('shape', '__VAL__')");
                 
        // === –°–ï–¢–ö–ê –ü–ê–†–ê–ú–ï–¢–†–û–í (GRID) ===
        html += `<div class="control-grid-2">`;
        
        // 1. –®–∏—Ä–∏–Ω–∞ / –†–∞–∑–º–µ—Ä
        if(t.shape === 'parallelepiped') { 
            html += mkStepper('–®–∏—Ä–∏–Ω–∞', t.w || 200, "updateTierProp('w', this.value)", "stepProp('w', -1)", "stepProp('w', 1)"); 
        } else { 
            html += mkStepper('–†–∞–∑–º–µ—Ä', t.d, "updateTierProp('d', this.value)", "stepProp('d', -1)", "stepProp('d', 1)"); 
        }

        // 2. –ì–ª—É–±–∏–Ω–∞ / –í—ã—Å–æ—Ç–∞
        if(t.shape === 'sphere') {
             html += `<div style="display:flex;align-items:center;justify-content:center;color:#999;font-size:10px">(–°–∏–º–º–µ—Ç—Ä–∏—è)</div>`;
        } else if (t.shape === 'parallelepiped') {
             html += mkStepper('–ì–ª—É–±–∏–Ω–∞', t.dep || 200, "updateTierProp('dep', this.value)", "stepProp('dep', -1)", "stepProp('dep', 1)");
        } else {
             html += mkStepper('–í—ã—Å–æ—Ç–∞', t.h, "updateTierProp('h', this.value)", "stepProp('h', -1)", "stepProp('h', 1)");
        }
        html += `</div>`; // –ö–æ–Ω–µ—Ü —Å—Ç—Ä–æ–∫–∏ 1

        // –°—Ç—Ä–æ–∫–∞ 2 (–µ—Å–ª–∏ –Ω—É–∂–Ω–∞ –≤—ã—Å–æ—Ç–∞ –¥–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –∏–ª–∏ —É–≥–ª—ã)
        if (t.shape === 'parallelepiped' || t.shape === 'ngon') {
             html += `<div class="control-grid-2">`;
             if (t.shape === 'parallelepiped') {
                 html += mkStepper('–í—ã—Å–æ—Ç–∞', t.h, "updateTierProp('h', this.value)", "stepProp('h', -1)", "stepProp('h', 1)");
             } else {
                 html += mkStepper('–£–≥–ª—ã', t.n || 6, "updateTierProp('n', this.value)", "stepProp('n', -1)", "stepProp('n', 1)");
             }
             html += mkStepper('–í–µ—Å (–∫–≥)', t.weight||0, "updateTierProp('weight', this.value)", "stepProp('weight', -0.1)", "stepProp('weight', 0.1)");
             html += `</div>`;
        } else {
             // –ü—Ä–æ—Å—Ç–æ –≤–µ—Å –æ—Ç–¥–µ–ª—å–Ω–æ, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∏ 2 –Ω–µ—Ç
             html += `<div class="control-group"><label class="control-label">–í–µ—Å (–∫–≥)</label><div class="stepper"><button onclick="stepProp('weight', -0.1)">-</button><input type="number" value="${t.weight||0}" step="0.1" oninput="updateTierProp('weight', this.value)"><button onclick="stepProp('weight', 0.1)">+</button></div></div>`;
        }

        // –ù–∞—á–∏–Ω–∫–∞
        html += `<div class="control-group"><label class="control-label">–ù–∞—á–∏–Ω–∫–∞</label><input type="text" class="btn-sec" style="width:100%" value="${t.filling||''}" onchange="updateTierProp('filling', this.value)"></div>`;

        // –ü–æ–¥–ª–æ–∂–∫–∞ (—Ç–æ–ª—å–∫–æ –Ω–∏–∑)
        if (ui.selTier === 0) {
            const b = t.board || { enabled: false, color: '#FFD700', thickness: 3, offset: 20 };
            html += `<hr style="border:0; border-top:1px solid #eee; margin:16px 0">`;
            html += `<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px">
                        <label class="control-label" style="margin:0">ü•Ø –ü–æ–¥–ª–æ–∂–∫–∞</label>
                        <input type="checkbox" ${b.enabled ? 'checked' : ''} onchange="toggleBoard(this.checked)" style="width:20px; height:20px; accent-color:#ec4899">
                     </div>`;
            if (b.enabled) {
                html += `<div style="background:#fff; padding:10px; border-radius:10px; border:1px solid #ddd">
                            <div style="display:flex; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #eee">
                                <input type="checkbox" id="board-round" ${(b.isRound!==false)?'checked':''} onchange="updateBoardProp('isRound', this.checked)" style="width:18px; height:18px; accent-color:#ec4899">
                                <label for="board-round" style="margin-left:8px; font-weight:600; font-size:13px; color:#333">–í—Å–µ–≥–¥–∞ –∫—Ä—É–≥–ª–∞—è</label>
                            </div>
                            <div style="display:flex; gap:8px; margin-bottom:8px; align-items:center">
                                <input type="color" value="${b.color}" onchange="updateBoardProp('color', this.value)" style="border:none; width:40px; height:30px">
                                <span style="font-size:12px">–¶–≤–µ—Ç –ø–æ–¥–ª–æ–∂–∫–∏</span>
                            </div>
                            <div class="control-grid-2">
                                ${mkStepper('–¢–æ–ª—â–∏–Ω–∞', b.thickness, "updateBoardProp('thickness', this.value)", "stepBoardProp('thickness', -1)", "stepBoardProp('thickness', 1)")}
                                ${mkStepper('–û—Ç—Å—Ç—É–ø', b.offset, "updateBoardProp('offset', this.value)", "stepBoardProp('offset', -5)", "stepBoardProp('offset', 5)")}
                            </div>
                         </div>`;
            }
        }
        
        html += `<div class="btn-grid" style="margin-top:20px"><button class="btn-sec" onclick="duplicateTier()">–ö–æ–ø–∏—è</button><button class="btn-sec" style="color:red; border-color:red" onclick="removeTier()">–£–¥–∞–ª–∏—Ç—å</button></div>`;
                  
    // --- –ú–ï–ù–Æ: –¶–í–ï–¢ ---
    } else if (menuName === 'color') {
        if(ui.selTier === null) html = '<p style="color:#999; text-align:center">–í—ã–±–µ—Ä–∏—Ç–µ —è—Ä—É—Å</p>';
        else {
            const t = getActiveTiers()[ui.selTier];
            title.innerHTML = 'üé® –û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ';
            html += `<div class="tab-switch"><button class="tab-btn ${ui.colorTab==='solid'?'active':''}" onclick="setTab('solid')">–ó–∞–ª–∏–≤–∫–∞</button><button class="tab-btn ${ui.colorTab==='texture'?'active':''}" onclick="setTab('texture')">–¢–µ–∫—Å—Ç—É—Ä–∞</button></div>`;
            
            if (ui.colorTab === 'solid') {
                html += `<div class="control-group"><label class="control-label">–ü–æ–∫—Ä—ã—Ç–∏–µ</label>
                <select class="btn-sec" style="width:100%; margin-bottom:12px" onchange="updateTierProp('coating', this.value)">
                    <option value="cream" ${t.coating==='cream'?'selected':''}>üç∞ –ö—Ä–µ–º-—á–∏–∑</option>
                    <option value="velvet" ${t.coating==='velvet'?'selected':''}>‚òÅÔ∏è –í–µ–ª—é—Ä</option>
                    <option value="mastic" ${t.coating==='mastic'?'selected':''}>üç¨ –ú–∞—Å—Ç–∏–∫–∞</option>
                    <option value="mirror" ${t.coating==='mirror'?'selected':''}>‚ú® –ó–µ—Ä–∫–∞–ª—å–Ω–∞—è</option>
                </select></div>`;
                
                html += `<input type="color" style="width:100%; height:50px; border:none; border-radius:10px; margin-bottom:16px" value="${t.color}" oninput="previewTierColor(this.value)" onchange="updateTierProp('color', this.value)">`;
                html += `<div class="palette">${['#ffffff','#ec4899','#fcd34d','#60a5fa','#34d399','#a78bfa'].map(c => `<div class="swatch" style="background:${c}" onclick="updateTierProp('color', '${c}')"></div>`).join('')}</div>`;
                
                // –ü–æ–¥—Ç–µ–∫–∏
                if(t.shape === 'cylinder' || t.shape === 'box' || t.shape === 'parallelepiped') {
                    const dr = t.drips || { enabled: false, color: '#3e2723', len: 40, freq: 12 };
                    html += `<hr style="border:0; border-top:1px solid #eee; margin:16px 0">`;
                    html += `<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px">
                                <label class="control-label" style="margin:0">üç´ –ü–æ–¥—Ç–µ–∫–∏</label>
                                <input type="checkbox" ${dr.enabled?'checked':''} onchange="toggleDrips(this.checked)" style="width:20px; height:20px">
                             </div>`;
                    if(dr.enabled) {
                        html += `<div style="background:#fff; padding:10px; border-radius:10px; border:1px solid #ddd">
                                    <div style="display:flex; gap:8px; margin-bottom:8px; align-items:center">
                                        <input type="color" value="${dr.color}" onchange="updateDrips('color', this.value)" style="border:none; width:40px; height:30px">
                                        <span style="font-size:12px">–¶–≤–µ—Ç –≥–ª–∞–∑—É—Ä–∏</span>
                                    </div>
                                    <div class="control-grid-2">
                                        ${mkStepper('–î–ª–∏–Ω–∞', dr.len, "updateDrips('len', this.value)", "stepDrips('len', -5)", "stepDrips('len', 5)")}
                                        ${mkStepper('–ß–∞—Å—Ç–æ—Ç–∞', dr.freq, "updateDrips('freq', this.value)", "stepDrips('freq', -1)", "stepDrips('freq', 1)")}
                                    </div>
                                 </div>`;
                    }
                } else {
                    html += `<div style="font-size:11px; color:#999; margin-top:10px">‚ö†Ô∏è –ü–æ–¥—Ç–µ–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –¶–∏–ª–∏–Ω–¥—Ä–∞/–ö—É–±–∞</div>`;
                }

            } else {
                // –¢–µ–∫—Å—Ç—É—Ä—ã
                if(!t.tex) t.tex = {side:defaultTex(), top:defaultTex(), bottom:defaultTex()}; 
                const p = ui.activeTexPart; const texData = t.tex[p]; const hasTex = !!texData.url;
                
                html += `<div class="control-group"><label class="control-label">–ó–æ–Ω–∞</label><select class="btn-sec" style="width:100%" onchange="setTexPart(this.value)"><option value="side" ${p==='side'?'selected':''}>–ë–æ–∫</option><option value="top" ${p==='top'?'selected':''}>–í–µ—Ä—Ö</option><option value="bottom" ${p==='bottom'?'selected':''}>–ù–∏–∑</option></select></div>`;
                html += `<div class="btn-grid" style="margin-bottom:16px"><button class="btn-sec" onclick="document.getElementById('tex-upl').click()">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>${hasTex ? `<button class="btn-sec" style="color:red" onclick="clearTexture()">‚ùå –£–¥–∞–ª–∏—Ç—å</button>` : ''}</div><input type="file" id="tex-upl" style="display:none" onchange="handleTextureUpload(this)">`;
                
                if (hasTex) {
                    html += `<div class="control-group" style="display:flex; align-items:center; gap:8px; margin-bottom:12px; background:#fff; padding:8px; border-radius:8px; border:1px solid #ddd;">
                                <input type="checkbox" id="tex-mix" ${texData.mixColor ? 'checked' : ''} onchange="updateTexProp('mixColor', this.checked)">
                                <label for="tex-mix" style="margin:0; font-weight:600; font-size:13px">–ù–∞–ª–æ–∂–∏—Ç—å —Ü–≤–µ—Ç —è—Ä—É—Å–∞ (Tint)</label>
                             </div>`;
                    const texModes = [
    {val:'tile', label:'–ü–ª–∏—Ç–∫–∞ (–ü–æ–≤—Ç–æ—Ä)', icon:'‚ñ¶'},
    {val:'fit', label:'–†–∞—Å—Ç—è–Ω—É—Ç—å (Fit)', icon:'‚ÜîÔ∏è'}
];
html += mkSelector('–†–µ–∂–∏–º –Ω–∞–ª–æ–∂–µ–Ω–∏—è', texData.mode, texModes, "updateTexProp('mode', '__VAL__')");
                    
                    // –°–µ—Ç–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Ç–µ–∫—Å—Ç—É—Ä—ã
                    html += `<div class="control-grid-2">
                        ${mkStepper('–ú–∞—Å—à—Ç–∞–±', texData.scale, "updateTexProp('scale', this.value)", "stepTex('scale', -0.1)", "stepTex('scale', 0.1)")}
                        ${mkStepper('–ü–æ–≤–æ—Ä–æ—Ç', texData.rot, "updateTexProp('rot', this.value)", "stepTex('rot', -5)", "stepTex('rot', 5)")}
                    </div>`;
                    html += `<div class="control-grid-2">
                        ${mkStepper('–°–¥–≤–∏–≥ X', texData.offX, "updateTexProp('offX', this.value)", "stepTex('offX', -0.05)", "stepTex('offX', 0.05)")}
                        ${mkStepper('–°–¥–≤–∏–≥ Y', texData.offY, "updateTexProp('offY', this.value)", "stepTex('offY', -0.05)", "stepTex('offY', 0.05)")}
                    </div>`;
                    if(texData.mode === 'tile') {
                        html += `<div class="control-grid-2">
                            ${mkStepper('–ü–æ–≤—Ç–æ—Ä X', texData.repX, "updateTexProp('repX', this.value)", "stepTex('repX', -0.5)", "stepTex('repX', 0.5)")}
                            ${mkStepper('–ü–æ–≤—Ç–æ—Ä Y', texData.repY, "updateTexProp('repY', this.value)", "stepTex('repY', -0.5)", "stepTex('repY', 0.5)")}
                        </div>`;
                    }
                } else { html += `<div style="text-align:center; padding:20px; color:#aaa; font-size:12px">–ù–µ—Ç —Ç–µ–∫—Å—Ç—É—Ä—ã –Ω–∞ —ç—Ç–æ–π —á–∞—Å—Ç–∏</div>`; }
            }
        }

    // --- –ú–ï–ù–Æ: –î–ï–ö–û–† ---
    } else if (menuName === 'decor') {
        title.innerHTML = '‚ú® –î–µ–∫–æ—Ä';
        if(ui.selTier === null) {
            html = '<p style="text-align:center">–í—ã–±–µ—Ä–∏—Ç–µ —è—Ä—É—Å</p>';
        } else {
            const t = getActiveTiers()[ui.selTier];
            
            // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –ú—É–ª—å—Ç–∏-–≤—ã–±–æ—Ä
            html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
                        <div class="control-label" style="margin:0">–°–ª–æ–∏ (${t.decor.length})</div>
                        <button class="btn-sec" style="width:auto; padding:4px 12px; font-size:12px; ${isMultiSelect ? 'background:#ec4899; color:white; border-color:#ec4899' : ''}" onclick="toggleMultiSelectMode()">
                            ${isMultiSelect ? '‚úì –ì–æ—Ç–æ–≤–æ' : '‚òëÔ∏è –í—ã–±—Ä–∞—Ç—å'}
                        </button>
                     </div>`;
            
            // –°–ø–∏—Å–æ–∫ —Å–ª–æ–µ–≤
            html += `<div id="decor-list-box" style="max-height:150px; overflow-y:auto; background:#fff; border:1px solid #ddd; border-radius:8px; margin-bottom:12px;">`;
            if(t.decor.length === 0) html += `<div style="padding:8px; color:#999; font-size:11px">–ù–µ—Ç —ç–ª–µ–º–µ–Ω—Ç–æ–≤</div>`;
            t.decor.forEach((d, i) => {
                let displayName = d.customName;
                if (!displayName) {
                    if (d.isText) displayName = '"' + d.textContent + '"';
                    else if (d.placement === 'volume' || d.placement === 'topper') displayName = (d.shape === 'sphere' ? '‚ö™ –®–∞—Ä' : (d.shape === 'cube'?'üì¶ –ö—É–±':'–§–∏–≥—É—Ä–∞'));
                    else if (d.placement === 'topper') displayName = 'üö© –¢–æ–ø–ø–µ—Ä';
                    else displayName = 'üñº –°—Ç–∏–∫–µ—Ä';
                }
                const isSelected = isMultiSelect ? selectedDecors.includes(i) : (ui.selDecorIdx === i);
                const bg = isSelected ? '#fce7f3' : '#fff';
                const lockIcon = d.locked ? 'üîí ' : '';
                const checkIcon = isMultiSelect ? (isSelected ? '‚òëÔ∏è ' : '‚¨ú ') : '';
                const clickAction = isMultiSelect ? `toggleDecorSelection(${i})` : `selectDecor(${i})`;
                
                html += `<div id="decor-item-${i}" onclick="${clickAction}" style="padding:8px; border-bottom:1px solid #eee; background:${bg}; font-size:12px; display:flex; justify-content:space-between; cursor:pointer; align-items:center">
                            <span>${checkIcon}${i+1}. ${lockIcon}${displayName}</span>
                            ${!isMultiSelect ? `<span style="color:red; padding:0 8px" onclick="event.stopPropagation(); removeDecor(${i})">‚úï</span>` : ''}
                         </div>`;
            });
            html += `</div>`;

            // –ï—Å–ª–∏ —Ä–µ–∂–∏–º –ì–†–£–ü–ü–´
            if (isMultiSelect) {
                 html += `<div class="control-label">–î–µ–π—Å—Ç–≤–∏—è —Å –≥—Ä—É–ø–ø–æ–π</div>
                          <div class="btn-grid" style="margin-bottom:16px">
                             <button class="btn-sec" onclick="groupAction('lock')">üîí –ó–∞–∫—Ä–µ–ø–∏—Ç—å</button>
                             <button class="btn-sec" onclick="groupAction('unlock')">üîì –û—Ç–∫—Ä–µ–ø–∏—Ç—å</button>
                             <button class="btn-sec" style="color:red" onclick="groupAction('delete')">üóë –£–¥–∞–ª–∏—Ç—å</button>
                             <button class="btn-sec" onclick="duplicateDecor()">üìë –ö–æ–ø–∏—è</button>
                          </div>`;
                 // –î–∂–æ–π—Å—Ç–∏–∫ –¥–ª—è –≥—Ä—É–ø–ø—ã
                 if (selectedDecors.length > 0) {
                      const miniBtn = (icon, dir) => `<button class="btn-sec" onpointerdown="startMove('${dir}')" onpointerup="stopMove()" onpointerleave="stopMove()" style="width:40px;height:40px;padding:0;display:flex;align-items:center;justify-content:center;">${icon}</button>`;
                      html += `<div class="control-label" style="text-align:center">–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ</div>
                               <div style="display:grid; grid-template-columns: 40px 40px 40px; justify-content:center; gap:8px; margin-bottom:12px;">
                                 <div></div> ${miniBtn('‚ñ≤', 'up')} <div></div>
                                 ${miniBtn('‚óÄ', 'left')} <div style="font-size:9px;display:flex;align-items:center;justify-content:center;">MOVE</div> ${miniBtn('‚ñ∂', 'right')}
                                 <div></div> ${miniBtn('‚ñº', 'down')} <div></div>
                               </div>
                               <div style="display:flex; justify-content:center; gap:12px; margin-bottom:16px">
                                 <button class="btn-sec" onpointerdown="startMove('in')" onpointerup="stopMove()" onpointerleave="stopMove()" style="width:auto; padding:8px; font-size:12px">‚Üò –í–≥–ª—É–±—å</button>
                                 <button class="btn-sec" onpointerdown="startMove('out')" onpointerup="stopMove()" onpointerleave="stopMove()" style="width:auto; padding:8px; font-size:12px">‚Üñ –ù–∞—Ä—É–∂—É</button>
                               </div>`;
                 }
            } else {
                // –ï—Å–ª–∏ —Ä–µ–∂–∏–º –û–î–ò–ù–û–ß–ù–´–ô
                html += `<div class="control-label">–î–æ–±–∞–≤–∏—Ç—å</div>
                         <div class="btn-grid" style="grid-template-columns:1fr 1fr 1fr; margin-bottom:16px">
                            <button class="btn-sec" onclick="promptAddDecor('side')">+ –ë–æ–∫</button>
                            <button class="btn-sec" onclick="promptAddDecor('top')">+ –í–µ—Ä—Ö</button>
                            <button class="btn-sec" onclick="promptAddDecor('topper')">+ –¢–æ–ø–ø–µ—Ä</button>
                         </div>
                         <div class="control-label">3D –§–∏–≥—É—Ä—ã</div>
                         <div class="btn-grid" style="grid-template-columns:1fr 1fr 1fr; gap:8px; margin-bottom:16px">
                            <button class="btn-sec" onclick="addVolumeFigure('sphere')">‚ö™ –®–∞—Ä</button>
                            <button class="btn-sec" onclick="addVolumeFigure('cube')">üì¶ –ö—É–±</button>
                            <button class="btn-sec" onclick="addVolumeFigure('cylinder')">üïØ –°–≤–µ—á–∞</button>
                         </div>`;

                // –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ
                if(ui.selDecorIdx !== null && t.decor[ui.selDecorIdx]) {
                    const d = t.decor[ui.selDecorIdx];
                    const miniBtn = (icon, dir) => `<button class="btn-sec" onpointerdown="startMove('${dir}')" onpointerup="stopMove()" onpointerleave="stopMove()" style="width:40px;height:40px;padding:0;display:flex;align-items:center;justify-content:center;">${icon}</button>`;

                    html += `<div class="control-label">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</div>
                             <div style="background:#f8f9fa; padding:10px; border-radius:12px; border:1px solid #eee">
                                <div style="margin-bottom:12px">
                                   <label style="font-size:10px; font-weight:700; color:#888; text-transform:uppercase; margin-bottom:4px; display:block">–ù–∞–∑–≤–∞–Ω–∏–µ</label>
                                   <input type="text" value="${d.customName || ''}" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –ë–∞–Ω—Ç" class="btn-sec" style="width:100%; font-size:14px; padding:8px;" onchange="renameDecor(this.value)">
                                </div>`;
                    
                    // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞
                    html += `<div onclick="toggleDecorLock(!${d.locked})" style="margin-bottom:12px; background:#fff; padding:8px; border-radius:8px; border:1px solid ${d.locked ? '#ec4899' : '#ddd'}; display:flex; align-items:center; justify-content:space-between; cursor:pointer">
                                <div style="display:flex; align-items:center">
                                    <span style="font-size:16px; margin-right:6px">${d.locked ? 'üîí' : 'üîì'}</span>
                                    <span style="font-weight:600; font-size:13px; margin:0; color:#333">${d.locked ? '–ó–∞–∫—Ä–µ–ø–ª–µ–Ω' : '–ó–∞–∫—Ä–µ–ø–∏—Ç—å'}</span>
                                </div>
                                <input type="checkbox" ${d.locked ? 'checked' : ''} style="width:20px; height:20px; accent-color:#ec4899; pointer-events:none;">
                             </div>`;

                    // –¢–∏–Ω—Ç (—Ü–≤–µ—Ç –∫–∞—Ä—Ç–∏–Ω–∫–∏)
                    if (!d.isText && d.placement !== 'volume') {
                        html += `<div class="control-group" style="margin-top:12px; border-bottom:1px solid #eee; padding-bottom:12px;">
                                    <label class="control-label">üé® –¢–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å (–§–∏–ª—å—Ç—Ä)</label>
                                    <div style="display:flex; gap:10px; align-items:center;">
                                        <input type="color" value="${d.tintColor || '#ffffff'}" style="height:40px; width:60px; border:none; padding:0;" oninput="updateDecorTint(this.value)">
                                        <button class="btn-sec" onclick="updateDecorTint('#ffffff')" style="padding:8px 12px; font-size:12px;">–°–±—Ä–æ—Å</button>
                                    </div>
                                 </div>`;
                    }
                    
                    // –¢–µ–∫—Å—Ç
                    if (d.isText) {
                        html += `<div style="margin-bottom:16px; border-bottom:1px solid #ddd; padding-bottom:12px;">
                                    <div class="control-label" style="color:#ec4899">üÖ∞ –¢–µ–∫—Å—Ç</div>
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px">
                                        <input type="color" value="${d.color || '#000000'}" style="height:30px; width:40px; border:none; padding:0;" oninput="updateDecorTextProp('color', this.value)">
                                        <span style="font-size:12px">–¶–≤–µ—Ç</span>
                                    </div>
                                    <select class="btn-sec" style="width:100%; margin-bottom:8px;" onchange="updateDecorTextProp('font', this.value)">
                                        ${GFONTS.map(f => `<option value='${f.f}' style='font-family:${f.f}' ${d.font===f.f?'selected':''}>${f.n}</option>`).join('')}
                                    </select>
                                    <button class="btn-sec" style="margin-top:8px; border:1px dashed #ec4899; color:#ec4899; width:100%" onclick="autoSizeDecor()">‚ú® –ê–≤—Ç–æ-—Ä–∞–∑–º–µ—Ä</button>
                                 </div>`;
                    }

                    // –¶–≤–µ—Ç 3D
                    if (d.placement === 'volume') {
                        html += `<div style="margin-bottom:16px; border-bottom:1px solid #ddd; padding-bottom:12px;">
                                    <div class="control-label">üé® –¶–≤–µ—Ç —Ñ–∏–≥—É—Ä—ã</div>
                                    <input type="color" value="${d.color || '#ffffff'}" style="height:40px; width:100%; border:none;" oninput="updateVolumeColor(this.value)">
                                 </div>`;
                    }

                    // –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ
                    if (d.placement === 'volume' || d.placement === 'topper') {
                        html += `<div class="control-label">–í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ</div>
                                 <div class="btn-grid" style="grid-template-columns: 1fr 1fr; gap:8px; margin-bottom:16px">
                                    <button class="btn-sec" onclick="alignDecor('centerX')">–¶–µ–Ω—Ç—Ä X</button>
                                    <button class="btn-sec" onclick="alignDecor('centerZ')">–¶–µ–Ω—Ç—Ä Z</button>
                                    <button class="btn-sec" onclick="alignDecor('straight')" style="grid-column: span 2;">–í—ã–ø—Ä—è–º–∏—Ç—å (Rot=0)</button>
                                 </div>`;
                    }

                    // –î–∂–æ–π—Å—Ç–∏–∫ (–æ–¥–∏–Ω–æ—á–Ω—ã–π)
                    html += `<div style="display:grid; grid-template-columns: 40px 40px 40px; justify-content:center; gap:4px; margin-bottom:12px;">
                                <div></div> ${miniBtn('‚ñ≤', 'up')} <div></div>
                                ${miniBtn('‚óÄ', 'left')} <div style="font-size:9px;display:flex;align-items:center;justify-content:center;">MOVE</div> ${miniBtn('‚ñ∂', 'right')}
                                <div></div> ${miniBtn('‚ñº', 'down')} <div></div>
                             </div>
                             <div class="btn-grid" style="margin-bottom:16px">
                                ${miniBtn('‚Üò', 'in')} ${miniBtn('‚Üñ', 'out')}
                             </div>`;

                    // –°–∏–º–º–µ—Ç—Ä–∏—è
                    html += `<div class="control-label">‚ùÑÔ∏è –°–∏–º–º–µ—Ç—Ä–∏—è</div>
                             <div class="btn-grid" style="grid-template-columns: repeat(4, 1fr); gap:6px; margin-bottom:16px">
                                <button class="btn-sec" onclick="makeSymmetry(2)">x2</button>
                                <button class="btn-sec" onclick="makeSymmetry(4)">x4</button>
                                <button class="btn-sec" onclick="makeSymmetry(6)">x6</button>
                                <button class="btn-sec" onclick="makeSymmetry(8)">x8</button>
                             </div>`;

                    // –†–∞–∑–º–µ—Ä—ã (–°–ï–¢–ö–ê)
                    html += `<div class="control-label">–†–∞–∑–º–µ—Ä—ã (–º–º)</div>
                             <div style="margin-bottom:8px; background:#fff; padding:4px; border-radius:8px; border:1px solid #ddd; display:flex; align-items:center;">
                                <input type="checkbox" id="lock-aspect" ${ui.lockAspect ? 'checked' : ''} onchange="toggleAspect(this.checked)" style="width:16px; height:16px; accent-color:#ec4899">
                                <label for="lock-aspect" style="margin-left:8px; font-weight:600; font-size:11px;">–°–æ—Ö—Ä–∞–Ω—è—Ç—å –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏</label>
                             </div>
                             <div class="control-grid-2">
                                ${mkStepper('‚Üî –®–∏—Ä–∏–Ω–∞', d.w, "updateDecorDim('w', this.value)", "stepDecorDim('w', -2)", "stepDecorDim('w', 2)")}
                                ${mkStepper('‚Üï –í—ã—Å–æ—Ç–∞', d.h, "updateDecorDim('h', this.value)", "stepDecorDim('h', -2)", "stepDecorDim('h', 2)")}
                             </div>`;
                             
                    // –í—Ä–∞—â–µ–Ω–∏–µ
                    html += `<div class="control-label">–í—Ä–∞—â–µ–Ω–∏–µ (${d.rot||0}¬∞)</div>
                             <div style="display:flex; align-items:center; gap:4px; margin-bottom:12px">
                                <button class="btn-sec" onclick="stepDecorDim('rot', -45)" style="width:40px">-45</button>
                                <input type="range" min="-180" max="180" value="${d.rot||0}" step="1" style="flex:1" oninput="updateDecorDim('rot', this.value)">
                                <button class="btn-sec" onclick="stepDecorDim('rot', 45)" style="width:40px">+45</button>
                             </div>`;

                    // 3D –ù–∞–∫–ª–æ–Ω—ã
                    if (d.placement === 'volume' || d.placement === 'topper') {
                        html += `<div class="control-grid-2">
                                    <div class="control-group"><label class="control-label">–ù–∞–∫–ª–æ–Ω X</label><input type="range" min="-180" max="180" value="${d.rotX || 0}" oninput="updateVolumeRot('rotX', this.value)" style="width:100%"></div>
                                    <div class="control-group"><label class="control-label">–ù–∞–∫–ª–æ–Ω Z</label><input type="range" min="-180" max="180" value="${d.rotZ || 0}" oninput="updateVolumeRot('rotZ', this.value)" style="width:100%"></div>
                                 </div>`;
                    }

                    // –î–µ–π—Å—Ç–≤–∏—è
                    html += `<div class="control-label">–î–µ–π—Å—Ç–≤–∏—è</div>
                             <div class="btn-grid" style="grid-template-columns: 1fr 1fr; margin-bottom:16px">
                                <button class="btn-sec" onclick="duplicateDecor()">üìë –ö–æ–ø–∏—è</button>
                                <button class="btn-sec" onclick="copyDecorToOther()">‚û° –í –¥—Ä—É–≥–æ–π —Ç–æ—Ä—Ç</button>
                             </div>`;
                             
                    html += `</div>`; // –ó–∞–∫—Ä—ã–≤–∞–µ–º –±–ª–æ–∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                }
            }
        }

    // --- –ú–ï–ù–Æ: –í–ò–î ---
    } else if (menuName === 'scene') {
        title.innerHTML = 'üì∑ –í–∏–¥';
        
        if (viewMode === 'both') {
            html += `<div class="control-label">‚Üî –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ç–æ—Ä—Ç–∞–º–∏</div>
                     <div style="display:flex; align-items:center; gap:12px; margin-bottom:20px; background:#fff; padding:10px; border-radius:10px; border:1px solid #ddd">
                        <span style="font-size:12px; font-weight:bold; color:#666">–ë–ª–∏–∑–∫–æ</span>
                        <input type="range" min="150" max="600" step="10" value="${cakeGap}" style="flex:1; accent-color:#ec4899; height:20px" oninput="updateCakeGap(this.value)">
                        <span style="font-size:12px; font-weight:bold; color:#666">–î–∞–ª–µ–∫–æ</span>
                     </div>`;
        }

        html += `<div class="control-label">–†–∞–∫—É—Ä—Å</div>
                 <div class="btn-grid" style="grid-template-columns: 1fr 1fr 1fr 1fr; margin-bottom:16px">
                    <button class="btn-sec" onclick="setCamView('front')">F</button>
                    <button class="btn-sec" onclick="setCamView('left')">L</button>
                    <button class="btn-sec" onclick="setCamView('right')">R</button>
                    <button class="btn-sec" onclick="setCamView('top')">T</button>
                 </div>
                 <button class="btn-sec" onclick="setCamView('reset')" style="width:100%; margin-bottom:16px">üîÑ –°–±—Ä–æ—Å (ISO)</button>
                 <button class="btn-full" onclick="takeScreenshot()">üì∏ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –°–∫—Ä–∏–Ω—à–æ—Ç</button>`;

    // --- –ú–ï–ù–Æ: –ü–†–û–ï–ö–¢ ---
    } else if (menuName === 'project') {
        title.innerHTML = 'üíæ –§–∞–π–ª –∏ AR';
        const dateStr = new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}).replace(':','-');
        const defaultName = `Cake_${dateStr}`;

        html += `<div class="control-label">–ù–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç</div>
                 <button class="btn-sec" onclick="resetProject()" style="width:100%; color:red; border-color:red; margin-bottom:20px">üóë –°–±—Ä–æ—Å–∏—Ç—å –≤—Å—ë</button>

                 <div class="control-label">–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ</div>
                 <button class="btn-full" onclick="saveProject()">–°–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª –ø—Ä–æ–µ–∫—Ç–∞</button>
                 <button class="btn-sec" onclick="loadProject()" style="margin-top:8px; width:100%">–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ–µ–∫—Ç</button>
                 
                 <hr style="border:0; border-top:1px solid #eee; margin:20px 0">
                 
                 <div class="control-label" style="color:#4f46e5">üì± –≠–∫—Å–ø–æ—Ä—Ç –≤ AR (3D)</div>
                 <div style="margin-bottom:12px">
                    <label style="font-size:11px; color:#666; display:block; margin-bottom:4px">–ò–º—è —Ñ–∞–π–ª–∞</label>
                    <input type="text" id="export-name" value="${defaultName}" class="btn-sec" style="width:100%; border:1px solid #4f46e5; color:#333">
                 </div>
                 <div class="btn-grid">
                    <button class="btn-sec" style="border:1px solid #4f46e5; color:#4f46e5" onclick="exportAR('usdz')">üçè iPhone (.usdz)</button>
                    <button class="btn-sec" style="border:1px solid #4f46e5; color:#4f46e5" onclick="exportAR('glb')">ü§ñ Android (.glb)</button>
                 </div>`;
    }

    content.innerHTML = html;
    
    // --- 2. –í–û–°–°–¢–ê–ù–ê–í–õ–ò–í–ê–ï–ú –°–ö–†–û–õ–õ ---
    if (menuName === 'decor') {
        const newList = document.getElementById('decor-list-box');
        if (newList) {
            if (wasDecorListOpen) {
                newList.scrollTop = savedScroll;
            } else {
                // –ï—Å–ª–∏ –æ—Ç–∫—Ä—ã–ª–∏ –≤–ø–µ—Ä–≤—ã–µ, —Å–∫—Ä–æ–ª–ª–∏–º –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É
                if (typeof scrollTarget !== 'undefined' && scrollTarget !== null) {
                    const item = document.getElementById(`decor-item-${scrollTarget}`);
                    if (item) item.scrollIntoView({ block: 'center', behavior: 'auto' });
                } else if (ui.selDecorIdx !== null) {
                    const item = document.getElementById(`decor-item-${ui.selDecorIdx}`);
                    if (item) item.scrollIntoView({ block: 'center', behavior: 'auto' });
                }
            }
        }
    }
}
/* --- 4. FUNCTIONS --- */

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –º–µ–Ω—é (–ß–∏–ø—Å–æ–≤)
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –º–µ–Ω—é (–ß–∏–ø—Å–æ–≤) + –í–ò–ë–†–ê–¶–ò–Ø
function mkSelector(label, currentVal, options, onSelectStr) {
    let html = `<div class="control-group">`;
    if(label) html += `<label class="control-label">${label}</label>`;
    
    html += `<div class="chip-scroll">`;
    
    options.forEach(opt => {
        const isActive = (opt.val === currentVal);
        const safeVal = opt.val.replace(/'/g, "\\'");
        
        // –î–û–ë–ê–í–ò–õ–ò: vibro('light'); –ø–µ—Ä–µ–¥ –≤—ã–∑–æ–≤–æ–º –ª–æ–≥–∏–∫–∏
        html += `<button class="chip-btn ${isActive ? 'active' : ''}" 
                         onclick="vibro('light'); ${onSelectStr.replace('__VAL__', safeVal)}">
                    ${opt.icon ? `<span>${opt.icon}</span>` : ''}
                    <span>${opt.label}</span>
                 </button>`;
    });
    
    html += `</div></div>`;
    return html;
}

                      
/* --- HAPTIC FEEDBACK --- */
function vibro(force) {
    if (navigator.vibrate) {
        // 'light' = –ª–µ–≥–∫–∏–π —â–µ–ª—á–æ–∫ (10–º—Å)
        // 'medium' = –æ–±—ã—á–Ω–æ–µ –Ω–∞–∂–∞—Ç–∏–µ (25–º—Å)
        // –∏–Ω–∞—á–µ = –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ –º—Å
        const ms = (force === 'light') ? 10 : ((force === 'medium' || !force) ? 25 : force);
        navigator.vibrate(ms);
    }
}
  
function mkStepper(lbl, val, onInp, onDec, onInc) {
    const safeDec = onDec.replace(/'/g, "\\'");
    const safeInc = onInc.replace(/'/g, "\\'");

    // –î–û–ë–ê–í–ò–õ–ò: vibro('medium') –≤ onpointerdown
    return `<div class="control-group">
              <label class="control-label">${lbl}</label>
              <div class="stepper">
                <button onpointerdown="vibro('medium'); startHold('${safeDec}')" onpointerup="stopHold()" onpointerleave="stopHold()">-</button>
                <input type="number" value="${val}" oninput="${onInp}">
                <button onpointerdown="vibro('medium'); startHold('${safeInc}')" onpointerup="stopHold()" onpointerleave="stopHold()">+</button>
              </div>
            </div>`;
}

function renderCompareTable() {
    const c = document.getElementById('cmp-content'); c.innerHTML = '';
    cakes.forEach((tiers, i) => {
        let colHtml = '<div class="cmp-col">'; let totalH = 0; let totalW = 0;
        [...tiers].reverse().forEach((t) => {
            const h = (t.shape==='sphere' ? t.d : t.h); totalH += h; totalW += (t.weight || 0);
            const dimStr = (t.shape==='box') ? `${t.d/10}x${t.d/10}` : (t.shape==='parallelepiped' ? `${t.w/10}x${t.dep/10}` : `√ò${t.d/10}`);
            colHtml += `<div class="cmp-tier"><strong>${dimStr} —Å–º</strong> | h ${h/10} —Å–º<br>${t.filling || '-'}<br>${t.weight || 0} –∫–≥</div>`;
        });
        colHtml += `<div style="margin-top:4px; font-weight:bold; border-top:1px solid #ccc; padding-top:4px">–í—ã—Å–æ—Ç–∞: ${totalH/10} —Å–º<br>–í–µ—Å: ${Math.round(totalW*10)/10} –∫–≥</div></div>`;
        c.innerHTML += colHtml;
    });
}

// –í–≤–æ–¥ –≤—Ä—É—á–Ω—É—é (–Ø—Ä—É—Å—ã)
function updateTierProp(key, val) {
    if(ui.selTier === null) return;
    const t = getActiveTiers()[ui.selTier];
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ —á–∏—Å–ª–∞ –¥–ª—è —Ä–∞–∑–º–µ—Ä–æ–≤
    if(['d','h','w','dep','n'].includes(key)) val = parseInt(val);
    else if(key==='weight') val = parseFloat(val);
    
    t[key] = val;
    
    rebuildScene();
    recordHistory();
    if(viewMode === 'both') renderCompareTable();
    
    // --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï ---
    // –ï—Å–ª–∏ –º—ã –∏–∑–º–µ–Ω–∏–ª–∏ –§–û–†–ú–£ (shape), –Ω—É–∂–Ω–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å –º–µ–Ω—é,
    // —á—Ç–æ–±—ã –ø–æ—è–≤–∏–ª–∏—Å—å –Ω—É–∂–Ω—ã–µ –ø–æ–ª—è (–®–∏—Ä–∏–Ω–∞/–ì–ª—É–±–∏–Ω–∞ –≤–º–µ—Å—Ç–æ –î–∏–∞–º–µ—Ç—Ä–∞).
    if (key === 'shape') {
        openMenu('structure_edit');
    }
}

function stepProp(key, delta) {
    if(ui.selTier === null) return;
    const t = getActiveTiers()[ui.selTier];
    let val = (parseFloat(t[key])||0) + delta;
    if(key==='weight'){ val = Math.round(val*10)/10; if(val<0) val=0; } else { if(val<3) val=3; }
    t[key] = val;
    
    // –†—É—á–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–ø—É—Ç–∞
    const inputs = document.querySelectorAll('#sheet-content input[type=number]');
    inputs.forEach(inp => { 
        const attr = inp.getAttribute('oninput'); 
        if(attr && attr.includes(`'${key}'`)) inp.value = val; 
    });

    rebuildScene();
    recordHistory();
    if(viewMode === 'both') renderCompareTable();
}
// –ö–Ω–æ–ø–∫–∏ +/- (–Ø—Ä—É—Å—ã)
function stepProp(key, delta) {
    if(ui.selTier === null) return;
    const t = getActiveTiers()[ui.selTier];
    let val = (parseFloat(t[key])||0) + delta;
    
    // –õ–∏–º–∏—Ç—ã
    if(key==='weight'){ val = Math.round(val*10)/10; if(val<0) val=0; } 
    else { if(val<3) val=3; } // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä 3–º–º
    
    t[key] = val;
    
    // –í–ê–ñ–ù–û: –ù–∞—Ö–æ–¥–∏–º –∏–Ω–ø—É—Ç –Ω–∞ —ç–∫—Ä–∞–Ω–µ –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Ä—É—á–Ω—É—é
    const inputs = document.querySelectorAll('#sheet-content input[type=number]');
    inputs.forEach(inp => { 
        // –ò—â–µ–º –∏–Ω–ø—É—Ç, —É –∫–æ—Ç–æ—Ä–æ–≥–æ –≤ –∞—Ç—Ä–∏–±—É—Ç–µ oninput –µ—Å—Ç—å –∏–º—è –Ω–∞—à–µ–≥–æ —Å–≤–æ–π—Å—Ç–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä 'd')
        const attr = inp.getAttribute('oninput'); 
        if(attr && attr.includes(`'${key}'`)) inp.value = val; 
    });

    rebuildScene();
    recordHistory();
    if(viewMode === 'both') renderCompareTable();
}

function stepTex(key, delta) {
    if(ui.selTier === null) return;
    const t = getActiveTiers()[ui.selTier]; const tex = t.tex[ui.activeTexPart];
    let val = (tex[key] || 0) + delta; val = Math.round(val * 100) / 100; tex[key] = val;
    const inputs = document.querySelectorAll('#sheet-content input[type=number]');
    inputs.forEach(inp => { const onInputAttr = inp.getAttribute('oninput'); if(onInputAttr && onInputAttr.includes(`'${key}'`)) inp.value = val; });
    rebuildScene(); recordHistory();
}

function setTab(t) { vibro('light');ui.colorTab = t; openMenu('color'); }
function setTexPart(p) { ui.activeTexPart = p; openMenu('color'); }
function compressImage(file, maxSize, callback) {
    const reader = new FileReader(); reader.onload = e => {
        const img = new Image(); img.onload = () => {
            let w = img.width, h = img.height; if (w > maxSize || h > maxSize) { const ratio = maxSize / Math.max(w, h); w *= ratio; h *= ratio; }
            const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, w, h); ctx.drawImage(img, 0, 0, w, h); callback(canvas.toDataURL('image/png'));
        }; img.src = e.target.result;
    }; reader.readAsDataURL(file);
}
function handleTextureUpload(inp) { if(!inp.files[0] || ui.selTier===null) return; compressImage(inp.files[0], 1024, (b64) => { const t = getActiveTiers()[ui.selTier]; if(!t.tex) t.tex = {side:defaultTex(), top:defaultTex(), bottom:defaultTex()}; t.tex[ui.activeTexPart].url = b64; t.tex[ui.activeTexPart].scale = 1; t.tex[ui.activeTexPart].mode = 'tile'; rebuildScene(); recordHistory(); openMenu('color'); }); inp.value = ''; }
function clearTexture() { if(ui.selTier === null) return; const t = getActiveTiers()[ui.selTier]; t.tex[ui.activeTexPart] = defaultTex(); rebuildScene(); recordHistory(); openMenu('color'); }

function updateTexProp(key, val) { 
    if(ui.selTier === null) return; 
    const t = getActiveTiers()[ui.selTier]; const tex = t.tex[ui.activeTexPart]; 
    if(key !== 'mode' && typeof val !== 'boolean') val = parseFloat(val); // Fix for boolean checkbox
    tex[key] = val; 
    rebuildScene(); recordHistory(); 
}

function switchCake(id) {
  vibro(30);
    // ... (–∫–æ–¥ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è viewMode –∫–∞–∫ –∏ –±—ã–ª) ...
    if (id === 'both') { 
        viewMode = 'both'; activeCakeId = 0; 
        document.getElementById('compare-overlay').style.display = 'block'; renderCompareTable(); 
    } else { 
        viewMode = 'single'; activeCakeId = id; 
        document.getElementById('compare-overlay').style.display = 'none'; 
    } 
    
    document.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active')); 
    if(id === 'both') document.getElementById('seg-both').classList.add('active'); 
    else document.getElementById(`seg-${id}`).classList.add('active'); 
    
    // –í–´–ó–´–í–ê–ï–ú –û–ë–ù–û–í–õ–ï–ù–ò–ï –ö–ê–ú–ï–†–´ (–ß—Ç–æ–±—ã –≤—ã—Å—Ç–∞–≤–∏—Ç—å –≤—ã—Å–æ—Ç—É –Ω–æ–≤–æ–≥–æ —Ç–æ—Ä—Ç–∞)
    updateCameraTarget(); 
    
    rebuildScene(); 
    closeSheet(); 
}
// forceCenter = true —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å–º–µ–Ω–µ —Ç–æ—Ä—Ç–∞ (–∫–Ω–æ–ø–∫–∏ A/B)

function updateCameraTarget() {
    // –ü—Ä–æ—Å—Ç–æ —Å—á–∏—Ç–∞–µ–º –≤—ã—Å–æ—Ç—É —Ç–æ—Ä—Ç–∞, —á—Ç–æ–±—ã –∫–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–µ–ª–∞ –≤ —Ü–µ–Ω—Ç—Ä
    let totalHeight = 0;
    const currentTiers = cakes[activeCakeId];
    if (currentTiers && currentTiers.length > 0) {
        currentTiers.forEach(t => {
            const h = (t.shape === 'sphere') ? t.d : (t.h || 0);
            totalHeight += h;
        });
    }
    // –í—ã—Å—Ç–∞–≤–ª—è–µ–º –≤—ã—Å–æ—Ç—É –ø—Ä–∏—Ü–µ–ª–∞ –Ω–∞ —Å–µ—Ä–µ–¥–∏–Ω—É —Ç–æ—Ä—Ç–∞
    const targetY = (totalHeight > 0) ? totalHeight / 2 : 100;
    
    controls.target.y = targetY;
    // X –∏ Z –≤—ã—Å—Ç–∞–≤–∏—Ç —Ñ—É–Ω–∫—Ü–∏—è animate() –≤ —Å–ª–µ–¥—É—é—â–µ–º –∫–∞–¥—Ä–µ
    
    controls.update();
}
  
function setCamView(type) { 
    let tx = 0; 
    // –û–±–Ω–æ–≤–ª–µ–Ω–æ: –∏—Å–ø–æ–ª—å–∑—É–µ–º cakeGap –≤–º–µ—Å—Ç–æ 220
    if (viewMode === 'single') tx = (activeCakeId === 0) ? -cakeGap : cakeGap; 
    
    controls.target.set(tx, 100, 0); 
    
    if (type === 'front') camera.position.set(tx, 100, 600); 
    if (type === 'left') camera.position.set(tx - 600, 100, 0); 
    if (type === 'right') camera.position.set(tx + 600, 100, 0); 
    if (type === 'top') camera.position.set(tx, 800, 0); 
    if (type === 'reset') camera.position.set(tx + 400, 300, 400); 
    
    controls.update(); 
}

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ç–∞–π–º–µ—Ä –¥–ª—è –¥–æ–ª–≥–æ–≥–æ –Ω–∞–∂–∞—Ç–∏—è
let longPressTimer = null;
let longPressMoveHandler = null; // <--- –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£

function onPointerDown(e) {
    if(e.target.closest('.bottom-sheet') || e.target.closest('.toolbar') || e.target.closest('.top-bar')) return;

    // 1. –ó–ê–ü–û–ú–ò–ù–ê–ï–ú –ú–ï–°–¢–û –ù–ê–ñ–ê–¢–ò–Ø
    tapStartX = e.clientX;
    tapStartY = e.clientY;

    // --- –õ–û–ì–ò–ö–ê –õ–ò–ù–ï–ô–ö–ò ---
    if (rulerMode) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(group.children, true);
        if (hits.length > 0) {
            const point = hits[0].point;
            if (rulerStep === 0) {
                clearRulerVisuals();
                rulerStart.copy(point);
                rulerMarkerA = createDot(point, 0x00ff00);
                rulerStep = 1;
                if (navigator.vibrate) navigator.vibrate(50);
            } else {
                rulerMarkerB = createDot(point, 0xff0000);
                rulerLine = drawLine(rulerStart, point);
                const dist = rulerStart.distanceTo(point);
                const label = document.getElementById('measure-label');
                label.innerText = Math.round(dist) + ' –º–º';
                label.style.display = 'block';
                updateMeasureLabel();
                if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
                rulerStep = 0;
            }
            renderer.render(scene, camera);
        }
        return;
    }

    // --- –û–ë–´–ß–ù–´–ô –†–ï–ñ–ò–ú (–ü–û–ò–°–ö –û–ë–™–ï–ö–¢–ê) ---
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(group.children, true);

    let targetObj = null;

    // 2. –ï–°–õ–ò –í–û –ß–¢–û-–¢–û –ü–û–ü–ê–õ–ò - –ü–´–¢–ê–ï–ú–°–Ø –ü–û–ù–Ø–¢–¨, –ß–¢–û –≠–¢–û
    if (hits.length > 0) {
        const firstHit = hits[0];
        
        // –£–º–Ω—ã–π –ø–æ–∏—Å–∫: –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –î–µ–∫–æ—Ä—É, –µ—Å–ª–∏ –æ–Ω —Ä—è–¥–æ–º (–≤ —Ä–∞–¥–∏—É—Å–µ 5 –µ–¥–∏–Ω–∏—Ü)
        let foundHit = hits.find(h => 
            h.distance < firstHit.distance + 5 && 
            (
                (h.object.userData.type === 'decor') || 
                (h.object.parent && h.object.parent.userData.type === 'decor')
            )
        );

        // –ï—Å–ª–∏ –¥–µ–∫–æ—Ä–∞ —Ä—è–¥–æ–º –Ω–µ—Ç, –∏—â–µ–º –Ø—Ä—É—Å
        if (!foundHit) {
            foundHit = hits.find(h => h.object.userData.type || (h.object.parent && h.object.parent.userData.type));
        }

        // –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–∞–º –æ–±—ä–µ–∫—Ç –∏–∑ Hilt
        if (foundHit) {
            let obj = foundHit.object;
            if(!obj.userData.type && obj.parent && obj.parent.userData.type) obj = obj.parent;
            targetObj = obj; // –ù–ê–®–õ–ò –í–ê–õ–ò–î–ù–£–Æ –¶–ï–õ–¨!
        }
    }

    // 3. –ì–õ–ê–í–ù–ê–Ø –†–ê–ó–í–ò–õ–ö–ê
    if (targetObj) {
        // === –ü–û–ü–ê–õ–ò –í –û–ë–™–ï–ö–¢ (–Ø–†–£–° –ò–õ–ò –î–ï–ö–û–†) ===
        const ud = targetObj.userData;

        // –ï—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –ø–æ –¥—Ä—É–≥–æ–º—É —Ç–æ—Ä—Ç—É –≤ —Ä–µ–∂–∏–º–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        if(viewMode === 'both' && ud.cIdx !== activeCakeId) {
            activeCakeId = ud.cIdx;
            updateCameraTarget();
        }

        ui.selTier = ud.tIdx; // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —è—Ä—É—Å

        if(ud.type === 'decor') {
            // --- –î–ï–ö–û–† ---
            const decorItem = getActiveTiers()[ud.tIdx].decor[ud.dIdx];
            
            if (decorItem.locked) {
                // –õ–æ–≥–∏–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ (Long Press)
                isDragging = false; controls.enabled = true;
                longPressMoveHandler = function(ev) {
                    const dist = Math.hypot(ev.clientX - tapStartX, ev.clientY - tapStartY);
                    if (dist > 10) {
                        if (longPressTimer) clearTimeout(longPressTimer);
                        longPressTimer = null;
                        window.removeEventListener('pointermove', longPressMoveHandler);
                        longPressMoveHandler = null;
                    }
                };
                window.addEventListener('pointermove', longPressMoveHandler);

                longPressTimer = setTimeout(() => {
                    decorItem.locked = false; 
                    ui.selDecorIdx = ud.dIdx; ui.selTier = ud.tIdx; 
                    openMenu('decor');
                    if (navigator.vibrate) navigator.vibrate(50);
                    if (longPressMoveHandler) {
                        window.removeEventListener('pointermove', longPressMoveHandler);
                        longPressMoveHandler = null;
                    }
                    isDragging = true; controls.enabled = false; 
                    dragData = {
                        startX: tapStartX, startY: tapStartY,
                        startValX: decorItem.x || 0, startValY: decorItem.y || 0, startValZ: decorItem.z || 0,
                        placement: decorItem.placement
                    };
                    window.addEventListener('pointermove', onPointerMove);
                    window.addEventListener('pointerup', onPointerUp);
                }, 1000);
                return; 
            }

            // –û–±—ã—á–Ω—ã–π –≤—ã–±–æ—Ä –¥–µ–∫–æ—Ä–∞
            let indicesToDrag = [];
            if (isMultiSelect) {
                if (selectedDecors.includes(ud.dIdx)) indicesToDrag = [...selectedDecors];
                else { toggleDecorSelection(ud.dIdx); return; }
            } else {
                ui.selDecorIdx = ud.dIdx; openMenu('decor');
                if (decorItem.symId) {
                    const tier = getActiveTiers()[ud.tIdx];
                    tier.decor.forEach((d, i) => { if (d.symId === decorItem.symId) indicesToDrag.push(i); });
                } else indicesToDrag = [ud.dIdx];
            }
            
            isDragging = true; controls.enabled = false; 
            dragData = { startX: e.clientX, startY: e.clientY, targets: [] };
            const tier = getActiveTiers()[ud.tIdx];
            indicesToDrag.forEach(idx => {
                const d = tier.decor[idx];
                if (d.locked) return;
                dragData.targets.push({ obj: d, startValX: d.x||0, startValY: d.y||0, startValZ: d.z||0, placement: d.placement });
            });
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);

        } else {
            // === –Ø–†–£–° (–° –û–ë–ù–û–í–õ–ï–ù–ò–ï–ú –ú–ï–ù–Æ) ===
            ui.selDecorIdx = null; 
            ui.selTier = ud.tIdx;

            // 1. –°–Ω–∞—á–∞–ª–∞ –æ–±–Ω–æ–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤ 3D (—Ä–æ–∑–æ–≤–∞—è –æ–±–≤–æ–¥–∫–∞)
            rebuildScene();

            // 2. –¢–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä—è–µ–º –º–µ–Ω—é.
            // –î–æ–±–∞–≤–∏–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É "|| ui.activeMenu === 'structure'", 
            // —á—Ç–æ–±—ã –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–ª–æ, –¥–∞–∂–µ –µ—Å–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Å—á–∏—Ç–∞–µ—Ç, —á—Ç–æ –º—ã –≤ —Å–ø–∏—Å–∫–µ.
            if (ui.activeMenu === 'structure_edit' || ui.activeMenu === 'structure') {
                 openMenu('structure_edit'); // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–æ–≤–æ–≥–æ —è—Ä—É—Å–∞
            } else if (ui.activeMenu === 'color') {
                 openMenu('color'); // –ï—Å–ª–∏ –±—ã–ª–∏ –≤ —Ü–≤–µ—Ç–µ ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç –¥–ª—è –Ω–æ–≤–æ–≥–æ —è—Ä—É—Å–∞
            } else if (ui.activeMenu === 'decor') {
                 openMenu('decor'); // –ï—Å–ª–∏ –±—ã–ª–∏ –≤ –¥–µ–∫–æ—Ä–µ ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ª–æ–∏ –Ω–æ–≤–æ–≥–æ —è—Ä—É—Å–∞
            }
        }
    } else {
        // === –ù–ò–ö–£–î–ê –ù–ï –ü–û–ü–ê–õ–ò (–ü–£–°–¢–û–¢–ê) ===
        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–±—Ä–æ—Å
        ui.selTier = null; 
        ui.selDecorIdx = null; 
        rebuildScene(); 
        closeSheet(); 
    }
}

function onPointerUp() {
    // 1. –ì–õ–ê–í–ù–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—Ç–º–µ–Ω—è–µ–º —Ç–∞–π–º–µ—Ä —è—Ä—É—Å–∞, –µ—Å–ª–∏ –ø–∞–ª–µ—Ü –ø–æ–¥–Ω—è—Ç
    

    // 2. –û—Ç–º–µ–Ω—è–µ–º —Ç–∞–π–º–µ—Ä –∑–∞–º–∫–∞ (–¥–µ–∫–æ—Ä)
    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }

    // 3. –£–¥–∞–ª—è–µ–º —Å–ª–µ–¥–∏–ª–∫—É –¥–≤–∏–∂–µ–Ω–∏—è (–¥–µ–∫–æ—Ä)
    if (longPressMoveHandler) {
        window.removeEventListener('pointermove', longPressMoveHandler);
        longPressMoveHandler = null;
    }

    // 4. –°–±—Ä–æ—Å –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å—Ç–∞—Ç—É—Å–æ–≤
    isDragging = false;
    controls.enabled = true;
    
    window.removeEventListener('pointermove', onPointerMove);
    window.removeEventListener('pointerup', onPointerUp);

    // –°–∫—Ä—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∏–µ
    if (snapLines.x) snapLines.x.visible = false;
    if (snapLines.z) snapLines.z.visible = false;
    
    document.getElementById('drag-tooltip').style.display = 'none';
    
    recordHistory();
    if (renderer.shadowMap.enabled) renderer.shadowMap.needsUpdate = true;
}

function onPointerMove(e) {
  
    
    // –ï—Å–ª–∏ –¥—Ä–∞–≥ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω
    if (!isDragging || !dragData || !dragData.targets || dragData.targets.length === 0) return;

    const dx = e.clientX - dragData.startX;
    const dy = e.clientY - dragData.startY;
    
    const angle = controls.getAzimuthalAngle();
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    // –¢—É–ª—Ç–∏–ø —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
    const tooltip = document.getElementById('drag-tooltip');
    
    // –§–ª–∞–≥–∏, —Å—Ä–∞–±–æ—Ç–∞–ª –ª–∏ –º–∞–≥–Ω–∏—Ç —Ö–æ—Ç—å —É –æ–¥–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
    let anySnapX = false;
    let anySnapZ = false;

    dragData.targets.forEach(item => {
        const d = item.obj;
        let newX, newY, newZ;

        if (item.placement === 'side') {
            // --- –°–¢–ò–ö–ï–†–´ ---
            const decorAng = (item.startValX) * Math.PI * 2; 
            const viewFactor = Math.cos(angle - decorAng); 
            const direction = (viewFactor >= 0) ? 1 : -1;
            
            // –°—ã—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            let rawX = (item.startValX + (dx * 0.0002 * direction)) % 1;
            if (rawX < 0) rawX += 1;

            // --- –ú–ê–ì–ù–ò–¢ (–ö —Ü–µ–Ω—Ç—Ä—É —Å–ø–µ—Ä–µ–¥–∏ 0.0, —Å–∑–∞–¥–∏ 0.5, —Å–ª–µ–≤–∞ 0.25, —Å–ø—Ä–∞–≤–∞ 0.75) ---
            const targets = [0, 0.25, 0.5, 0.75, 1.0];
            let snappedX = rawX;
            
            // –ò—â–µ–º –±–ª–∏–∂–∞–π—à—É—é —Ü–µ–ª—å
            for(let t of targets) {
                if (Math.abs(rawX - t) < SNAP_DIST_SIDE) {
                    snappedX = t;
                    anySnapX = true; // –°—Ä–∞–±–æ—Ç–∞–ª –º–∞–≥–Ω–∏—Ç!
                    if (t === 1.0) snappedX = 0; // 1.0 —ç—Ç–æ —Ç–æ –∂–µ —Å–∞–º–æ–µ —á—Ç–æ 0
                    break; 
                }
            }
            newX = snappedX;
            newY = item.startValY - (dy * 0.0002);

            d.x = newX;
            d.y = newY;

        } else if (item.placement === 'topper' || item.placement === 'volume') {
            // --- 3D –û–ë–™–ï–ö–¢–´ ---
            const moveX = (dx * cosA * 0.2);
            const moveZ = -(dx * sinA * 0.2);
            const moveY = -(dy * 0.2);

            let rawX = item.startValX + moveX;
            let rawZ = item.startValZ + moveZ;

            // --- –ú–ê–ì–ù–ò–¢ X ---
            if (Math.abs(rawX) < SNAP_DIST_3D) { 
                rawX = 0; 
                anySnapX = true; 
            }
            
            // --- –ú–ê–ì–ù–ò–¢ Z ---
            if (Math.abs(rawZ) < SNAP_DIST_3D) { 
                rawZ = 0; 
                anySnapZ = true; 
            }

            d.x = rawX;
            d.z = rawZ;
            d.y = item.startValY + moveY;
        } else {
            // --- TOP (–ö–†–´–®–ö–ê) ---
            const moveX = (dx * cosA + dy * sinA) * 0.25;
            const moveZ = (dy * cosA - dx * sinA) * 0.25;
            
            let rawX = item.startValX + moveX;
            let rawZ = item.startValZ + moveZ;

             // –ú–∞–≥–Ω–∏—Ç –∫ —Ü–µ–Ω—Ç—Ä—É
            if (Math.abs(rawX) < SNAP_DIST_3D) { rawX = 0; anySnapX = true; }
            if (Math.abs(rawZ) < SNAP_DIST_3D) { rawZ = 0; anySnapZ = true; }

            d.x = rawX;
            d.z = rawZ;
        }
    });

    // --- –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –ò –í–ò–ë–†–ê–¶–ò–Ø ---
    
    // –í–∏–±—Ä–∞—Ü–∏—è (—Ç–æ–ª—å–∫–æ –≤ –º–æ–º–µ–Ω—Ç –≤—Ö–æ–¥–∞ –≤ –∑–æ–Ω—É –º–∞–≥–Ω–∏—Ç–∞)
    if ((anySnapX && !isSnapped.x) || (anySnapZ && !isSnapped.z)) {
        if (navigator.vibrate) navigator.vibrate(15); // –û—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–π "—Ç—É–∫"
    }
    isSnapped.x = anySnapX;
    isSnapped.z = anySnapZ;

    // –†–∏—Å—É–µ–º –ª–∏–Ω–∏–∏
    // –ú—ã –ø–µ—Ä–µ–¥–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –ø–µ—Ä–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞, —á—Ç–æ–±—ã –∑–Ω–∞—Ç—å –≥–¥–µ —Ä–∏—Å–æ–≤–∞—Ç—å
    const firstObj = dragData.targets[0].obj;
    const pos = { x: firstObj.x, y: firstObj.y, z: firstObj.z };
    
    // –î–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤ –ª–æ–≥–∏–∫–∞ –ª–∏–Ω–∏–π –¥—Ä—É–≥–∞—è (–ø–æ–∫–∞ –æ—Ç–∫–ª—é—á–∏–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –ª–∏–Ω–∏–π –¥–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤, —Ç–∞–º —Å–ª–æ–∂–Ω–µ–µ —Å 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏)
    if (dragData.targets[0].placement !== 'side') {
        updateSnapLines(anySnapX, anySnapZ, pos);
    } else {
        // –î–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤ –º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ —Å–∫—Ä—ã—Ç—å –ª–∏–Ω–∏–∏
        if(snapLines.x) snapLines.x.visible = false;
        if(snapLines.z) snapLines.z.visible = false;
    }

    // --- –û–ë–ù–û–í–õ–ï–ù–ò–ï –¢–£–õ–¢–ò–ü–ê ---
    if (tooltip) {
        tooltip.style.display = 'block';
        tooltip.style.left = e.clientX + 'px';
        tooltip.style.top = e.clientY + 'px';
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫—Ä–∞—Å–∏–≤—ã–µ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ —Ü–∏—Ñ—Ä—ã
        // –ï—Å–ª–∏ —Å—Ç–∏–∫–µ—Ä: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º % (–Ω–∞–ø—Ä–∏–º–µ—Ä 25%)
        // –ï—Å–ª–∏ 3D: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–º (–Ω–∞–ø—Ä–∏–º–µ—Ä X: 12)
        if (firstObj.placement === 'side') {
            tooltip.innerText = `Pos: ${Math.round(firstObj.x * 100)}% | H: ${Math.round(firstObj.y * 100)}%`;
        } else {
            tooltip.innerText = `X: ${Math.round(firstObj.x)} Y: ${Math.round(firstObj.y)} Z: ${Math.round(firstObj.z)}`;
        }
    }
    
    rebuildScene();
}

function getActiveTiers() { return cakes[activeCakeId]; }
function closeSheet() { 
    const sh = document.getElementById('bottom-sheet');
    sh.classList.add('hidden-sheet'); // –ü—Ä—è—á–µ–º –≤–Ω–∏–∑
    sh.classList.remove('open'); 
    ui.activeMenu = null; 
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã—Å–æ—Ç—É –Ω–∞ –¥–µ—Ñ–æ–ª—Ç –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –æ—Ç–∫—Ä—ã—Ç–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    setTimeout(() => { sh.style.height = '40vh'; }, 300);
}
function recordHistory() { if (historyPtr < history.length - 1) history = history.slice(0, historyPtr + 1); history.push(JSON.stringify(cakes)); if (history.length > 30) history.shift(); else historyPtr++; if(viewMode === 'both') renderCompareTable(); }
function undo() { if (historyPtr > 0) { historyPtr--; cakes = JSON.parse(history[historyPtr]); rebuildScene(); if(ui.activeMenu) openMenu(ui.activeMenu); if(viewMode === 'both') renderCompareTable(); } }
function redo() { if (historyPtr < history.length - 1) { historyPtr++; cakes = JSON.parse(history[historyPtr]); rebuildScene(); if(ui.activeMenu) openMenu(ui.activeMenu); if(viewMode === 'both') renderCompareTable(); } }
function moveTier(dir) { if (ui.selTier === null) return; const tiers = getActiveTiers(); const newIdx = ui.selTier + dir; if (newIdx < 0 || newIdx >= tiers.length) return; [tiers[ui.selTier], tiers[newIdx]] = [tiers[newIdx], tiers[ui.selTier]]; ui.selTier = newIdx; rebuildScene(); openMenu('structure_edit'); recordHistory(); }
function actionAddTier() { getActiveTiers().push({id:Date.now(), shape:'cylinder', d:200, h:100, n:6, w:200, dep:200, color:'#ffffff', weight:2, filling:'–í–∞–Ω–∏–ª—å', decor:[], tex:{side:defaultTex(),top:defaultTex(),bottom:defaultTex()}}); ui.selTier = getActiveTiers().length - 1; rebuildScene(); openMenu('structure_edit'); recordHistory(); }
function selectAndEditTier(idx) { ui.selTier = idx; rebuildScene(); openMenu('structure_edit'); }
function previewTierColor(val) { if(ui.selTier === null) return; const t = getActiveTiers()[ui.selTier]; t.color = val; rebuildScene(); }
function duplicateTier() { if(ui.selTier!==null){ getActiveTiers().push(JSON.parse(JSON.stringify(getActiveTiers()[ui.selTier]))); ui.selTier=getActiveTiers().length-1; rebuildScene(); openMenu('structure_edit'); recordHistory(); }}
function removeTier() { if(ui.selTier!==null){ getActiveTiers().splice(ui.selTier,1); ui.selTier=null; rebuildScene(); closeSheet(); recordHistory(); }}
function getShapeName(s) { const n={cylinder:'–¶–∏–ª–∏–Ω–¥—Ä',box:'–ö—É–±',sphere:'–®–∞—Ä',ngon:'–ú–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫',heart:'–°–µ—Ä–¥—Ü–µ',star:'–ó–≤–µ–∑–¥–∞',parallelepiped:'–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥'}; return n[s]||s; }
function textToImg(txt, font, color) { 
    const cvs = document.createElement('canvas'); 
    const ctx = cvs.getContext('2d'); 
    
    // –û–ß–ï–ù–¨ –ë–û–õ–¨–®–û–ô –†–ê–ó–ú–ï–† –¥–ª—è —á–µ—Ç–∫–æ—Å—Ç–∏
    const fontSize = 200; 
    const fontStr = "bold " + fontSize + "px " + (font || 'Inter');
    
    // 1. –ò–∑–º–µ—Ä—è–µ–º —Ç–µ–∫—Å—Ç
    ctx.font = fontStr; 
    const lines = txt.split('\n'); 
    let maxW = 0; 
    lines.forEach(l => maxW = Math.max(maxW, ctx.measureText(l).width)); 
    
    // 2. –î–µ–ª–∞–µ–º –æ–≥—Ä–æ–º–Ω—ã–π –æ—Ç—Å—Ç—É–ø (padding), —á—Ç–æ–±—ã —Ö–≤–æ—Å—Ç—ã –±—É–∫–≤ (g, y, f) –Ω–µ –æ–±—Ä–µ–∑–∞–ª–∏—Å—å
    const lineHeight = fontSize * 1.5;
    const padding = fontSize; // –û—Ç—Å—Ç—É–ø —Ä–∞–≤–µ–Ω —Ä–∞–∑–º–µ—Ä—É –±—É–∫–≤—ã
    
    cvs.width = maxW + (padding * 2); 
    cvs.height = (lines.length * lineHeight) + padding; 
    
    // 3. –†–∏—Å—É–µ–º
    ctx.font = fontStr; 
    ctx.textBaseline = 'middle'; 
    ctx.textAlign = 'center'; 
    ctx.fillStyle = color || '#000000'; 
    
    // –¶–µ–Ω—Ç—Ä —Ö–æ–ª—Å—Ç–∞
    const cx = cvs.width / 2;
    const cy = cvs.height / 2;
    
    // –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ (—á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –±—ã–ª —Ä–æ–≤–Ω–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É)
    const totalTextH = lines.length * lineHeight;
    const startY = cy - (totalTextH / 2) + (lineHeight / 2);

    lines.forEach((l, i) => {
        ctx.fillText(l, cx, startY + (i * lineHeight)); 
    }); 
    
    return cvs.toDataURL('image/png'); 
}

// –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Ç–µ–ø–µ—Ä—å –£–ú–ï–ï–¢ –ñ–î–ê–¢–¨ –∑–∞–≥—Ä—É–∑–∫—É —à—Ä–∏—Ñ—Ç–∞
async function updateDecorTextProp(key, val) {
    if(ui.selTier===null || ui.selDecorIdx===null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    if(!d.isText) return;

    if(key === 'fontCustom') {
        d.font = val;
        loadFont(val);
    } else {
        d[key] = val;
        if(key === 'font') loadFont(val);
    }

    // 1. –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É —à—Ä–∏—Ñ—Ç–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    const fontStr = "100px " + d.font;

    try {
        // 2. –ñ–î–ï–ú –ó–ê–ì–†–£–ó–ö–ò (–ú–∞–≥–∏—è –∑–¥–µ—Å—å)
        await document.fonts.load(fontStr);
        // –ï—Å–ª–∏ –¥–æ—à–ª–∏ —Å—é–¥–∞ ‚Äî —à—Ä–∏—Ñ—Ç —Ç–æ—á–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω
    } catch (e) {
        console.log('–û—à–∏–±–∫–∞ –æ–∂–∏–¥–∞–Ω–∏—è —à—Ä–∏—Ñ—Ç–∞, —Ä–∏—Å—É–µ–º –∫–∞–∫ –µ—Å—Ç—å');
    }

    // 3. –†–∏—Å—É–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É
    d.url = textToImg(d.textContent, d.font, d.color);
    
    // 4. –ê–í–¢–û-–†–ê–ó–ú–ï–† (–ß—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Å–ø–ª—é—â–∏–≤–∞–Ω–∏—è)
    const img = new Image();
    img.onload = function() {
        if (d.lockAspect !== false) {
            const ratio = img.width / img.height;
            // –ï—Å–ª–∏ —Ç–æ–ø–ø–µ—Ä, —Ñ–∏–∫—Å–∏—Ä—É–µ–º –≤—ã—Å–æ—Ç—É (–Ω–∞–ø—Ä–∏–º–µ—Ä 40–º–º) –∏ –ø–æ–¥–≥–æ–Ω—è–µ–º —à–∏—Ä–∏–Ω—É
            // –ï—Å–ª–∏ —à–∏—Ä–∏–Ω–∞ –≤—ã—Ö–æ–¥–∏—Ç —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–±–æ–ª—å—à–µ –¥–∏–∞–º–µ—Ç—Ä–∞ —Ç–æ—Ä—Ç–∞), –º–æ–∂–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å
            d.w = Math.round(d.h * ratio);
        }
        rebuildScene();
        if(ui.activeMenu === 'decor') openMenu('decor'); // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–∏—Ñ—Ä—ã
    };
    img.src = d.url;
    
    rebuildScene();
}

function addTextDec() { const txt = document.getElementById('new-txt').value; if(!txt) return; const url = textToImg(txt, 'Inter', '#ec4899'); const t = getActiveTiers()[ui.selTier]; t.decor.push({type:'sticker', url:url, w:50, h:20, x:0, y:0.5, isText:true, textContent:txt, color:'#ec4899'}); rebuildScene(); closeSheet(); recordHistory(); }
function handleFile(inp) { if(!inp.files[0] || ui.selTier===null) return; compressImage(inp.files[0], 1024, (b64) => { getActiveTiers()[ui.selTier].decor.push({type:'sticker', url:b64, w:50, h:50, x:0, y:0.5}); rebuildScene(); closeSheet(); recordHistory(); }); }

function takeScreenshot() {
    // 1. –ó–ê–ü–û–ú–ò–ù–ê–ï–ú –¢–ï–ö–£–©–ò–ï –†–ê–ó–ú–ï–†–´ –ò –§–û–ù
    const oldSize = new THREE.Vector2();
    renderer.getSize(oldSize);
    const oldBg = scene.background;

    // 2. –ù–ê–°–¢–†–ê–ò–í–ê–ï–ú –°–¶–ï–ù–£
    // –°—Ç–∞–≤–∏–º —Å–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π —Ñ–æ–Ω (—á—Ç–æ–±—ã –±–µ–ª—ã–µ —Ü–∏—Ñ—Ä—ã –Ω–µ —Å–ª–∏–≤–∞–ª–∏—Å—å)
    scene.background = new THREE.Color(0xf0f2f5);

    // –í–∫–ª—é—á–∞–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å –ø–ª–∞—à–µ–∫ —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏
    scene.traverse(obj => {
        if (obj.userData && obj.userData.type === 'infoLabel') obj.visible = true;
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º –º–∏—Ä, —á—Ç–æ–±—ã –ø–ª–∞—à–∫–∏ —Ç–æ—á–Ω–æ –≤—Å—Ç–∞–ª–∏ –Ω–∞ —Å–≤–æ–∏ –º–µ—Å—Ç–∞
    scene.updateMatrixWorld(true);

    // 3. –£–í–ï–õ–ò–ß–ò–í–ê–ï–ú –†–ê–ó–†–ï–®–ï–ù–ò–ï (High Quality)
    // –£–º–Ω–æ–∂–∞–µ–º —Ä–∞–∑–º–µ—Ä –≤–∞—à–µ–≥–æ —ç–∫—Ä–∞–Ω–∞ –Ω–∞ 3. 
    // –≠—Ç–æ –¥–∞—Å—Ç —á–µ—Ç–∫—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É, –Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç –¢–û–ß–ù–û –¢–û–¢ –ñ–ï —Ä–∞–∫—É—Ä—Å, —á—Ç–æ –≤—ã –≤–∏–¥–∏—Ç–µ.
    const multiplier = 3; 
    renderer.setSize(oldSize.x * multiplier, oldSize.y * multiplier);

    // 4. –û–ë–ù–û–í–õ–Ø–ï–ú –¢–ï–ù–ò
    // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã —Ç–æ—Ä—Ç –Ω–µ —Å—Ç–∞–ª –ø–ª–æ—Å–∫–∏–º –Ω–∞ –Ω–æ–≤–æ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏
    renderer.shadowMap.needsUpdate = true;

    // 5. –†–ï–ù–î–ï–† –ò –°–û–•–†–ê–ù–ï–ù–ò–ï
    renderer.render(scene, camera);

    const dateStr = new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}).replace(':','-');
    const a = document.createElement('a');
    a.download = `cake_view_${dateStr}.png`;
    a.href = renderer.domElement.toDataURL('image/png', 1.0);
    a.click();

    // 6. –í–û–ó–í–†–ê–©–ê–ï–ú –í–°–Å –ö–ê–ö –ë–´–õ–û
    // –°–∫—Ä—ã–≤–∞–µ–º –ø–ª–∞—à–∫–∏ –æ–±—Ä–∞—Ç–Ω–æ
    scene.traverse(obj => {
        if (obj.userData && obj.userData.type === 'infoLabel') obj.visible = false;
    });

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–æ–Ω
    scene.background = oldBg;
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ã—á–Ω—ã–π —Ä–∞–∑–º–µ—Ä —ç–∫—Ä–∞–Ω–∞ (—á—Ç–æ–±—ã —Ç–µ–ª–µ—Ñ–æ–Ω –Ω–µ —Ç–æ—Ä–º–æ–∑–∏–ª)
    renderer.setSize(oldSize.x, oldSize.y);
    
    // –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    renderer.shadowMap.needsUpdate = true;
    renderer.render(scene, camera);
}

function saveProject(customName) { 
    const name = customName || 'cake_project';
    const b=new Blob([JSON.stringify(cakes)],{type:"application/json"}); 
    const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download = name + ".json"; a.click(); 
}
function loadProject() { const i=document.createElement('input'); i.type='file'; i.onchange=e=>{const r=new FileReader(); r.onload=ev=>{cakes=JSON.parse(ev.target.result); rebuildScene(); recordHistory();}; r.readAsText(e.target.files[0]);}; i.click(); }

/* --- NEW COPY FUNCTION --- */
function copyCakeToOther() {
    const srcId = activeCakeId;
    const destId = (srcId === 0) ? 1 : 0;
    const srcName = (srcId === 0) ? 'A' : 'B';
    const destName = (srcId === 0) ? 'B' : 'A';

    if(confirm(`–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –¢–æ—Ä—Ç ${srcName} –≤ –¢–æ—Ä—Ç ${destName}?\n–í—Å–µ –¥–∞–Ω–Ω—ã–µ –¢–æ—Ä—Ç–∞ ${destName} –±—É–¥—É—Ç –∑–∞–º–µ–Ω–µ–Ω—ã.`)) {
        cakes[destId] = JSON.parse(JSON.stringify(cakes[srcId]));
        rebuildScene();
        recordHistory(); 
        alert(`–¢–æ—Ä—Ç ${srcName} —É—Å–ø–µ—à–Ω–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ ${destName}!`);
        closeSheet();
    }
}
/* --- DECOR EXTENSIONS --- */
let tempDecorType = 'side'; // 'side', 'top', 'topper'

function promptAddDecor(type) {
    if(ui.selTier === null) { alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —è—Ä—É—Å!'); return; }
    tempDecorType = type;
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—ã–±–æ—Ä –ø—Ä—è–º–æ –≤ –º–µ–Ω—é
    const content = document.getElementById('sheet-content');
    content.innerHTML = `
        <div class="sheet-header" style="padding-left:0; border:none">
            <button class="back-btn" onclick="openMenu('decor')">‚Üê –ù–∞–∑–∞–¥</button>
            <div class="sheet-title">–ß—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å?</div>
        </div>
        <div class="btn-grid" style="margin-top:20px">
            <button class="btn-full" onclick="initAddDecor('img')">üñº –ö–∞—Ä—Ç–∏–Ω–∫–∞</button>
            <button class="btn-full" onclick="initAddDecor('text')">üî§ –¢–µ–∫—Å—Ç</button>
        </div>
        <input type="file" id="decor-upl" style="display:none" onchange="finishAddDecor(this)">
    `;
}

function initAddDecor(sourceType) {
    if (sourceType === 'img') {
        const fileInput = document.getElementById('decor-upl');
        if(fileInput) fileInput.click();
        else alert('–û—à–∏–±–∫–∞: —ç–ª–µ–º–µ–Ω—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω');
    } else {
        const txt = prompt("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∞–¥–ø–∏—Å–∏:");
        if(txt) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É –∏–∑ —Ç–µ–∫—Å—Ç–∞ (–ß–ï–†–ù–´–ô –¶–í–ï–¢ #000000)
            createDecorItem(textToImg(txt, 'Inter', '#000000'), true, txt);
        } else {
            openMenu('decor'); // –û—Ç–º–µ–Ω–∞
        }
    }
}

function finishAddDecor(inp) {
    if(!inp.files[0]) return;
    compressImage(inp.files[0], 1024, (b64) => { createDecorItem(b64, false); });
    inp.value = '';
}

function createDecorItem(url, isText, textContent) {
    const t = getActiveTiers()[ui.selTier];
    
    let initX = 0, initY = 0, initZ = 0;
    if (tempDecorType === 'side') { initY = 0.5; initX = 0.5; } 

    const item = { 
        url: url, placement: tempDecorType, 
        w: (isText ? 80 : 50), h: (isText ? 30 : 50), rot: 0, 
        x: initX, y: initY, z: initZ,
        // –ù–æ–≤—ã–µ –ø–æ–ª—è –¥–ª—è —Ç–µ–∫—Å—Ç–∞
        isText: isText || false,
        textContent: textContent || '',
        font: 'Inter',
        color: '#000000',
        
        tintColor: '#ffffff' // <--- –î–û–ë–ê–í–ò–õ–ò –í–û–¢ –≠–¢–û
    };
    
    t.decor.push(item);
    ui.selDecorIdx = t.decor.length - 1;
    rebuildScene();
    openMenu('decor');
    recordHistory();
}

function selectDecor(idx) {
    ui.selDecorIdx = idx;
    rebuildScene();
    openMenu('decor');
}

function removeDecor(idx) {
    getActiveTiers()[ui.selTier].decor.splice(idx, 1);
    ui.selDecorIdx = null;
    rebuildScene();
    openMenu('decor');
    recordHistory();
}

/* --- –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–û–ï –î–í–ò–ñ–ï–ù–ò–ï (–û–¢–ù–û–°–ò–¢–ï–õ–¨–ù–û –ö–ê–ú–ï–†–´) --- */
/* --- –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–û–ï –î–í–ò–ñ–ï–ù–ò–ï (–û–¢–ù–û–°–ò–¢–ï–õ–¨–ù–û –ö–ê–ú–ï–†–´) --- */
function moveDecor(dir) {
    if(ui.selTier === null) return;
    
    // –û–ü–†–ï–î–ï–õ–Ø–ï–ú –¶–ï–õ–ò –î–õ–Ø –î–í–ò–ñ–ï–ù–ò–Ø
    let targets = [];
    const tier = getActiveTiers()[ui.selTier];

    // 1. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ú—É–ª—å—Ç–∏-–≤—ã–±–æ—Ä (–≥–∞–ª–æ—á–∫–∏)
    if (isMultiSelect && selectedDecors.length > 0) {
        targets = selectedDecors.map(i => tier.decor[i]);
    } 
    // 2. –ò–Ω–∞—á–µ: –û–¥–∏–Ω–æ—á–Ω—ã–π –≤—ã–±–æ—Ä + –°–ò–ú–ú–ï–¢–†–ò–Ø
    else if (ui.selDecorIdx !== null) {
        const current = tier.decor[ui.selDecorIdx];
        
        // –ï–°–¢–¨ –õ–ò –£ –û–ë–™–ï–ö–¢–ê –°–ò–ú–ú–ï–¢–†–ò–Ø?
        if (current.symId) {
            // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ—Ö –±—Ä–∞—Ç—å–µ–≤ —Å —Ç–∞–∫–∏–º –∂–µ symId
            targets = tier.decor.filter(d => d.symId === current.symId);
        } else {
            // –ù–µ—Ç —Å–∏–º–º–µ—Ç—Ä–∏–∏, –¥–≤–∏–≥–∞–µ–º –æ–¥–∏–Ω
            targets = [current];
        }
    }

    if (targets.length === 0) return;

    // –û–ë–©–ò–ï –ü–ê–†–ê–ú–ï–¢–†–´ –°–ö–û–†–û–°–¢–ò
    const stepMove = 5;       // –º–º –¥–ª—è 3D –æ–±—ä–µ–∫—Ç–æ–≤
    const stepH = 2;          // –º–º –≤—ã—Å–æ—Ç—ã
    const stepRot = 5;        // –≥—Ä–∞–¥—É—Å—ã –ø–æ–≤–æ—Ä–æ—Ç–∞
    const stepSide = 0.01;    // —à–∞–≥ –¥–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤ –ø–æ –∫—Ä—É–≥—É
    const stepSideH = 0.02;   // —à–∞–≥ –≤—ã—Å–æ—Ç—ã –¥–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤
    const stepDepth = 1;      // —à–∞–≥ –≥–ª—É–±–∏–Ω—ã (–≤–¥–∞–≤–ª–∏–≤–∞–Ω–∏—è)

    // –£–≥–æ–ª –∫–∞–º–µ—Ä—ã –æ–¥–∏–Ω –¥–ª—è –≤—Å–µ—Ö
    const camAng = controls.getAzimuthalAngle();
    const sin = Math.sin(camAng);
    const cos = Math.cos(camAng);

    // –í–µ–∫—Ç–æ—Ä –Ω–∞–∂–∞—Ç–∏—è
    let sx = 0, sz = 0, sy = 0;
    if(dir === 'left') sx = -1;
    if(dir === 'right') sx = 1;
    if(dir === 'up') sy = 1;
    if(dir === 'down') sy = -1;
    if(dir === 'in') sz = -1;   
    if(dir === 'out') sz = 1;  

    // –ü–†–ò–ú–ï–ù–Ø–ï–ú –î–í–ò–ñ–ï–ù–ò–ï –ö–û –í–°–ï–ú –¶–ï–õ–Ø–ú
    targets.forEach(d => {
        if (d.locked) return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã, –¥–∞–∂–µ –µ—Å–ª–∏ –æ–Ω–∏ –≤—ã–¥–µ–ª–µ–Ω—ã

        // –í—Ä–∞—â–µ–Ω–∏–µ
        if(dir === 'rotCW') { d.rot = (d.rot || 0) - stepRot; return; }
        if(dir === 'rotCCW') { d.rot = (d.rot || 0) + stepRot; return; }

        if (d.placement === 'side') {
            // –î–í–ò–ñ–ï–ù–ò–ï –î–õ–Ø –°–¢–ò–ö–ï–†–û–í –ù–ê –ë–û–ö–£
            if (sy !== 0) d.y = (d.y || 0) + (sy * stepSideH);
            if (sz !== 0) d.z = (d.z || 0) + (sz * stepDepth); 

            if (sx !== 0) {
                // –£–º–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–∑–≥–ª—è–¥–∞ –∫–∞–º–µ—Ä—ã
                const decorAng = (d.x || 0) * Math.PI * 2; 
                const viewFactor = Math.cos(camAng - decorAng); 
                const direction = (viewFactor >= 0) ? 1 : -1;
                
                d.x = ((d.x || 0) + (sx * stepSide * direction));
                // –ó–∞—Ü–∏–∫–ª–∏–≤–∞–µ–º 0..1
                if(d.x > 1) d.x -= 1; 
                if(d.x < 0) d.x += 1;
            }
        } else {
            // –î–í–ò–ñ–ï–ù–ò–ï –î–õ–Ø 3D –û–ë–™–ï–ö–¢–û–í (–¢–æ–ø–ø–µ—Ä—ã, –§–∏–≥—É—Ä—ã, –ö–∞—Ä—Ç–∏–Ω–∫–∏ —Å–≤–µ—Ä—Ö—É)
            if (sy !== 0) d.y = (d.y || 0) + (sy * stepH);
            
            if (sx !== 0 || sz !== 0) {
                // –ü–æ–≤–æ—Ä–æ—Ç –≤–µ–∫—Ç–æ—Ä–∞ –¥–≤–∏–∂–µ–Ω–∏—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã
                const moveX = (sx * stepMove * cos) + (sz * stepMove * sin);
                const moveZ = -(sx * stepMove * sin) + (sz * stepMove * cos); 
                
                d.x = (d.x || 0) + moveX;
                d.z = (d.z || 0) + moveZ;
            }
        }
    });

    rebuildScene();
}
/* --- SIZE & ASPECT RATIO LOGIC --- */
function toggleAspect(checked) {
    ui.lockAspect = checked;
}

function updateDecorDim(key, val) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    
    // –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º –≤–≤–æ–¥ –≤ —á–∏—Å–ª–æ. –ï—Å–ª–∏ —Å—Ç–µ—Ä–ª–∏ –≤—Å—ë (–ø—É—Å—Ç–æ) ‚Äî —Å—á–∏—Ç–∞–µ–º –∫–∞–∫ 0
    let numVal = parseFloat(val);
    if(isNaN(numVal)) numVal = 0;

    if (key === 'rot') {
        d.rot = numVal;
        const range = document.querySelector('input[type=range]');
        if(range) range.value = numVal;
    } else {
        // --- –õ–û–ì–ò–ö–ê –°–û–•–†–ê–ù–ï–ù–ò–Ø –ü–†–û–ü–û–†–¶–ò–ô ---
        
        // 1. –ï—Å–ª–∏ —Ä–∞–∑–º–µ—Ä—ã –≤–∞–ª–∏–¥–Ω—ã–µ (>0), –∑–∞–ø–æ–º–∏–Ω–∞–µ–º "–∑–æ–ª–æ—Ç–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ" —ç—Ç–æ–≥–æ –¥–µ–∫–æ—Ä–∞
        // –ú—ã –¥–µ–ª–∞–µ–º —ç—Ç–æ –ü–ï–†–ï–î —Ç–µ–º, –∫–∞–∫ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (–∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –±—ã—Ç—å 0)
        if (d.w > 0 && d.h > 0) {
            d._ratio = d.w / d.h;
        }
        // –ï—Å–ª–∏ –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ –µ—â–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã, —Å—á–∏—Ç–∞–µ–º –∏—Ö 1:1
        if (!d._ratio) d._ratio = 1;

        // 2. –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–≤–µ–¥–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫ —Ç–µ–∫—É—â–µ–º—É –ø–æ–ª—é
        d[key] = numVal;

        // 3. –ï—Å–ª–∏ —Å—Ç–æ–∏—Ç –≥–∞–ª–æ—á–∫–∞ "–°–æ—Ö—Ä–∞–Ω—è—Ç—å –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏"
        if (ui.lockAspect && (key === 'w' || key === 'h')) {
            
            // –í–ê–ñ–ù–´–ô –ú–û–ú–ï–ù–¢: –ú–µ–Ω—è–µ–º –≤—Ç–æ—Ä–æ–µ –ø–æ–ª–µ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –≤–≤–µ–¥–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ > 0.
            // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—Ç–µ—Ä –ø–æ–ª–µ (numVal = 0), –≤—Ç–æ—Ä–æ–µ –ø–æ–ª–µ –º—ã –ù–ï —Ç—Ä–æ–≥–∞–µ–º.
            // –û–Ω–æ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –≤–∏—Å–µ—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –ø–æ–∫–∞ –≤—ã –Ω–µ –≤–ø–∏—à–µ—Ç–µ –Ω–æ–≤—É—é —Ü–∏—Ñ—Ä—É.
            if (numVal > 0) {
                if (key === 'w') { 
                    d.h = Math.round(numVal / d._ratio); 
                } else { 
                    d.w = Math.round(numVal * d._ratio); 
                }
            }
        }
        
        // 4. –û–±–Ω–æ–≤–ª—è–µ–º —Ü–∏—Ñ—Ä—ã –í–û –í–°–ï–• –∏–Ω–ø—É—Ç–∞—Ö (—á—Ç–æ–±—ã –æ–Ω–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–ª–∏—Å—å —Å —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å—é)
        const inputs = document.querySelectorAll('#sheet-content input[type=number]');
        inputs.forEach(inp => {
            const action = inp.getAttribute('oninput');
            if (!action) return;

            // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ–ª–µ —à–∏—Ä–∏–Ω—ã ('w') ‚Äî —Å—Ç–∞–≤–∏–º —Ç—É–¥–∞ –∞–∫—Ç—É–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É –∏–∑ –æ–±—ä–µ–∫—Ç–∞ (d.w)
            if (action.includes("'w'")) {
                inp.value = (d.w > 0 ? d.w : '');
            }
            
            // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ–ª–µ –≤—ã—Å–æ—Ç—ã ('h') ‚Äî —Å—Ç–∞–≤–∏–º —Ç—É–¥–∞ –∞–∫—Ç—É–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –∏–∑ –æ–±—ä–µ–∫—Ç–∞ (d.h)
            if (action.includes("'h'")) {
                inp.value = (d.h > 0 ? d.h : '');
            }
        });
    }
    
    rebuildScene();
    // openMenu –ù–ï –≤—ã–∑—ã–≤–∞–µ–º, —á—Ç–æ–±—ã —Ñ–æ–∫—É—Å –Ω–µ —Å–ª–µ—Ç–∞–ª
}

function stepDecorDim(key, delta) {
    if(ui.selTier===null || ui.selDecorIdx===null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    updateDecorDim(key, (parseFloat(d[key])||0) + delta);
}

/* --- CONTINUOUS MOVEMENT LOGIC (–£–ù–ò–í–ï–†–°–ê–õ–¨–ù–ê–Ø) --- */
// –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –æ—à–∏–±–∫–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è
if (typeof holdTimer === 'undefined') var holdTimer = null; 

// –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω—è–µ—Ç –õ–Æ–ë–û–ô –∫–æ–¥ –º–Ω–æ–≥–æ —Ä–∞–∑, –ø–æ–∫–∞ –¥–µ—Ä–∂–∏—à—å –∫–Ω–æ–ø–∫—É
function startHold(code) {
    if(holdTimer) clearInterval(holdTimer);
    const func = new Function(code);
    func(); // –°—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ä–∞–∑—É –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏
    holdTimer = setInterval(func, 100); // –ü–æ–≤—Ç–æ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 100–º—Å
}

function stopHold() {
    if(holdTimer) { clearInterval(holdTimer); holdTimer = null; }
}

// –û–±–µ—Ä—Ç–∫–∏ –¥–ª—è –¥–∂–æ–π—Å—Ç–∏–∫–∞ (—á—Ç–æ–±—ã —Å—Ç–∞—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ —Å—Ç—Ä–µ–ª–æ–∫ —Ä–∞–±–æ—Ç–∞–ª–∏)
function startMove(dir) { startHold("moveDecor('" + dir + "')"); }
function stopMove() { stopHold(); }


// --- –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —à—Ä–∏—Ñ—Ç–æ–≤ ---
function preloadFonts() {
    // –°–æ–∑–¥–∞–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–π –±–ª–æ–∫
    const hiddenDiv = document.createElement('div');
    hiddenDiv.style.position = 'absolute'; 
    hiddenDiv.style.top = '-9999px'; 
    hiddenDiv.style.visibility = 'hidden';
    document.body.appendChild(hiddenDiv);

    // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —à—Ä–∏—Ñ—Ç–∞ —Å–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç, —á—Ç–æ–±—ã –±—Ä–∞—É–∑–µ—Ä –Ω–∞—á–∞–ª —Å–∫–∞—á–∏–≤–∞—Ç—å —à—Ä–∏—Ñ—Ç
    GOOGLE_FONTS.forEach(font => {
        const span = document.createElement('span');
        span.style.fontFamily = font;
        span.textContent = 'Preload'; // –õ—é–±–æ–π —Ç–µ–∫—Å—Ç
        hiddenDiv.appendChild(span);
    });
    
    // –ñ–¥–µ–º —Å–µ–∫—É–Ω–¥—É –∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Å—Ü–µ–Ω—É (–Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ)
    setTimeout(() => rebuildScene(), 1000);
}
// –§—É–Ω–∫—Ü–∏—è –ª–µ—á–∏—Ç —Å–ø–ª—é—â–∏–≤–∞–Ω–∏–µ
function autoSizeDecor() {
    if(ui.selTier===null || ui.selDecorIdx===null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –µ—ë —Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
    const img = new Image();
    img.onload = function() {
        const ratio = img.width / img.height;
        // –ú–µ–Ω—è–µ–º —à–∏—Ä–∏–Ω—É 3D-–æ–±—ä–µ–∫—Ç–∞, —á—Ç–æ–±—ã –æ–Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞–ª–∞ –∫–∞—Ä—Ç–∏–Ω–∫–µ
        d.w = d.h * ratio; 
        
        rebuildScene(); 
        openMenu('decor'); // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–∏—Ñ—Ä—ã –≤ –º–µ–Ω—é
    };
    img.src = d.url;
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞ —Ç–µ–∫—Å—Ç–∞ –ø–æ —Å–ª–æ–≤–∞–º
function wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    let lines = [];
    let currentLine = words[0];

    for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const width = ctx.measureText(currentLine + " " + word).width;
        if (width < maxWidth) {
            currentLine += " " + word;
        } else {
            lines.push(currentLine);
            currentLine = word;
        }
    }
    lines.push(currentLine);
    return lines;
}

/* --- –ì–ï–ù–ï–†–ê–¢–û–† –ü–õ–ê–®–ï–ö (–í–ï–†–¢–ò–ö–ê–õ–¨–ù–´–ô –ü–ï–†–ï–ù–û–°) --- */
function createInfoSprite(t) {
    // 1. –ù–ê–°–¢–†–û–ô–ö–ò
    const fixedCanvasW = 500; // –ñ–µ—Å—Ç–∫–∞—è —à–∏—Ä–∏–Ω–∞ –ø–ª–∞—à–∫–∏
    const paddingX = 40;      // –û—Ç—Å—Ç—É–ø—ã –ø–æ –±–æ–∫–∞–º
    const paddingY = 40;      // –û—Ç—Å—Ç—É–ø—ã —Å–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É
    const gap = 20;           // –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –±–ª–æ–∫–∞–º–∏ —Ç–µ–∫—Å—Ç–∞
    const maxTextW = fixedCanvasW - (paddingX * 2); // –ú–∞–∫—Å. —à–∏—Ä–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞

    // –®—Ä–∏—Ñ—Ç—ã –∏ –∏—Ö –≤—ã—Å–æ—Ç—ã —Å—Ç—Ä–æ–∫ (line-height)
    const titleFont = "bold 56px Inter, sans-serif"; const titleLH = 70;
    const bodyFont = "48px Inter, sans-serif";       const bodyLH = 60;
    const infoFont = "italic 44px Inter, sans-serif"; const infoLH = 55;

    // –¢–µ–∫—Å—Ç—ã
    const dimText = (t.shape === 'box') ? `‚óº ${t.d/10}x${t.d/10} —Å–º` : 
                    (t.shape === 'parallelepiped' ? `‚ñ¨ ${t.w/10}x${t.dep/10} —Å–º` : `‚óè √ò ${t.d/10} —Å–º`);
    const hText = `‚Üï –í—ã—Å–æ—Ç–∞: ${t.h/10} —Å–º`;
    let infoText = `${t.weight||0} –∫–≥`;
    if(t.filling) infoText += ` | ${t.filling}`;

    // 2. –ü–û–î–ì–û–¢–û–í–ö–ê (–†–∞–∑–±–∏–≤–∫–∞ –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –∏ —Ä–∞—Å—á–µ—Ç –≤—ã—Å–æ—Ç—ã)
    const tempCvs = document.createElement('canvas'); const tempCtx = tempCvs.getContext('2d');

    tempCtx.font = titleFont;
    const titleLines = wrapText(tempCtx, dimText, maxTextW);
    const titleH = titleLines.length * titleLH;

    tempCtx.font = bodyFont;
    const bodyLines = wrapText(tempCtx, hText, maxTextW);
    const bodyH = bodyLines.length * bodyLH;

    tempCtx.font = infoFont;
    const infoLines = wrapText(tempCtx, infoText, maxTextW);
    const infoH = infoLines.length * infoLH;

    // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â—É—é –≤—ã—Å–æ—Ç—É –∫–∞–Ω–≤–∞—Å–∞
    const canvasH = paddingY + titleH + gap + bodyH + gap + infoH + paddingY;

    // 3. –†–ò–°–û–í–ê–ù–ò–ï
    const cvs = document.createElement('canvas');
    cvs.width = fixedCanvasW; 
    cvs.height = canvasH;
    const ctx = cvs.getContext('2d');

    // –§–æ–Ω –∏ —Ä–∞–º–∫–∞
    ctx.fillStyle = "#ffffff"; ctx.beginPath(); 
    ctx.roundRect(10, 10, fixedCanvasW-20, canvasH-20, 40); ctx.fill();
    ctx.strokeStyle = "#ec4899"; ctx.lineWidth = 8; ctx.stroke();

    // –¢–µ–∫—Å—Ç
    ctx.fillStyle = "#333"; ctx.textAlign = "left"; ctx.textBaseline = "middle";
    let currentY = paddingY; // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è Y

    // –ë–ª–æ–∫ 1: –ó–∞–≥–æ–ª–æ–≤–æ–∫
    ctx.font = titleFont;
    titleLines.forEach((line, i) => {
        ctx.fillText(line, paddingX, currentY + (i * titleLH) + titleLH/2);
    });
    currentY += titleH + gap;

    // –ë–ª–æ–∫ 2: –í—ã—Å–æ—Ç–∞
    ctx.font = bodyFont;
    bodyLines.forEach((line, i) => {
        ctx.fillText(line, paddingX, currentY + (i * bodyLH) + bodyLH/2);
    });
    currentY += bodyH + gap;

    // –ë–ª–æ–∫ 3: –ò–Ω—Ñ–æ
    ctx.fillStyle = "#666"; ctx.font = infoFont;
    infoLines.forEach((line, i) => {
        ctx.fillText(line, paddingX, currentY + (i * infoLH) + infoLH/2);
    });

    // 4. –°–û–ó–î–ê–ù–ò–ï –°–ü–†–ê–ô–¢–ê
    const tex = new THREE.CanvasTexture(cvs);
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    
    // –í–ï–†–ù–£–õ–ò –û–ë–´–ß–ù–´–ô –ú–ê–¢–ï–†–ò–ê–õ (–£–±—Ä–∞–ª–∏ depthTest: false)
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true }); 
    const sprite = new THREE.Sprite(mat);
    
    // –¢–ï–ü–ï–†–¨ –§–ò–ö–°–ò–†–£–ï–ú –®–ò–†–ò–ù–£ –í 3D
    const worldScaleW = 150; 
    const worldScaleH = worldScaleW * (canvasH / fixedCanvasW); 
    
    sprite.scale.set(worldScaleW, worldScaleH, 1);
    
    // –£–±—Ä–∞–ª–∏ renderOrder = 999, –æ–Ω –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω
    sprite.visible = false; 
    sprite.userData = { type: 'infoLabel' }; 
    return sprite;
}
/* --- –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò: –ú–ê–¢–ï–†–ò–ê–õ–´ –ò –ü–û–î–¢–ï–ö–ò --- */

// 1. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Ç–µ–∫—Å—Ç—É—Ä—ã —à—É–º–∞ (–¥–ª—è –í–µ–ª—é—Ä–∞)
function createNoiseTexture() {
    const size = 512; const canvas = document.createElement('canvas');
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext('2d'); ctx.fillStyle = '#808080'; ctx.fillRect(0,0,size,size);
    const data = ctx.getImageData(0,0,size,size); const buffer = data.data;
    for(let i=0; i<buffer.length; i+=4) {
        const val = (Math.random() - 0.5) * 40; // –°–∏–ª–∞ —à—É–º–∞
        buffer[i] += val; buffer[i+1] += val; buffer[i+2] += val;
    }
    ctx.putImageData(data, 0, 0);
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2, 2);
    return tex;
}
const NOISE_TEX = createNoiseTexture(); // –°–æ–∑–¥–∞–µ–º –æ–¥–∏–Ω —Ä–∞–∑

// 2. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–æ–¥—Ç–µ–∫–æ–≤ (–®–æ–∫–æ–ª–∞–¥)
// 2. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–æ–¥—Ç–µ–∫–æ–≤ (–¶–∏–ª–∏–Ω–¥—Ä + –ö—É–±)
// 2. –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–æ–¥—Ç–µ–∫–æ–≤ (–†–∞–∑–Ω–∞—è —Ç–æ–ª—â–∏–Ω–∞)
function createDrips(shape, w, d, color, len, freq) {
    const grp = new THREE.Group();
    
    // –ë–∞–∑–æ–≤–∞—è —Ç–æ–ª—â–∏–Ω–∞ –æ–±–æ–¥–∫–∞ (–≤–µ—Ä—Ö–Ω–µ–π –∫–∞–µ–º–∫–∏)
    const rimR = 0.7; 
    
    const mat = new THREE.MeshStandardMaterial({ 
        color: color, roughness: 0.3, metalness: 0.1 
    });

    // --- –¶–ò–õ–ò–ù–î–† / –ö–†–£–ì ---
    if (shape === 'cylinder' || shape === 'sphere') {
        const r = w; 
        
        // –û–±–æ–¥–æ–∫ (–†–æ–≤–Ω—ã–π, —á—Ç–æ–±—ã –±—ã–ª–æ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ)
        const rim = new THREE.Mesh(
            new THREE.TorusGeometry(r + rimR*0.5, rimR, 8, 32), 
            mat
        );
        rim.rotation.x = Math.PI / 2;
        grp.add(rim);

        // –ö–∞–ø–ª–∏
        const count = freq || 12; 
        for(let i=0; i<count; i++) {
            const angle = (i / count) * Math.PI * 2 + (Math.random() * 0.5); // –ù–µ–º–Ω–æ–≥–æ —Ö–∞–æ—Å–∞ –≤ –ø–æ–∑–∏—Ü–∏–∏
            
            // 1. –†–∞–Ω–¥–æ–º–Ω–∞—è –¥–ª–∏–Ω–∞
            const dropLen = (len || 40) * (0.6 + Math.random() * 0.7);
            
            // 2. –†–ê–ù–î–û–ú–ù–ê–Ø –®–ò–†–ò–ù–ê (–æ—Ç 0.4 –¥–æ 0.9 —Ä–∞–¥–∏—É—Å)
            const dropR = 0.4 + Math.random() * 0.5;

            // –°–∞–º–∞ –∫–∞–ø–ª—è
            const drop = new THREE.Mesh(new THREE.CylinderGeometry(dropR, dropR, dropLen, 8), mat);
            drop.geometry.translate(0, -dropLen/2, 0);
            
            // –ü–æ–∑–∏—Ü–∏—è
            drop.position.set(Math.cos(angle) * (r + rimR*0.5), 0, Math.sin(angle) * (r + rimR*0.5));
            
            // –ö–æ–Ω—á–∏–∫ (–°—Ñ–µ—Ä–∞)
            const tip = new THREE.Mesh(new THREE.SphereGeometry(dropR, 8, 8), mat);
            tip.position.y = -dropLen;
            drop.add(tip);
            
            grp.add(drop);
        }
    } 
    // --- –ö–£–ë / –ü–ê–†–ê–õ–õ–ï–õ–ï–ü–ò–ü–ï–î ---
    else if (shape === 'box' || shape === 'parallelepiped') {
        const hw = w/2; const hd = d/2;
        
        // –û–±–æ–¥–æ–∫ (4 –ø—Ä—è–º—ã–µ —Ç—Ä—É–±–∫–∏)
        const path = [
            {x:0, z:hd, w:w}, {x:0, z:-hd, w:w},
            {x:hw, z:0, w:d, rot:true}, {x:-hw, z:0, w:d, rot:true}
        ];
        path.forEach(p => {
            const bar = new THREE.Mesh(new THREE.CylinderGeometry(rimR, rimR, p.w + rimR*2, 8), mat);
            bar.rotation.z = Math.PI/2; 
            if(p.rot) bar.rotation.y = Math.PI/2;
            bar.position.set(p.x, 0, p.z);
            grp.add(bar);
        });

        // –ö–∞–ø–ª–∏
        const perimeter = (w + d) * 2;
        const count = Math.floor(perimeter / (150 / (freq/10)));
        
        for(let i=0; i<count; i++) {
            const side = Math.floor(Math.random() * 4);
            const offset = (Math.random() - 0.5); 
            let px=0, pz=0;
            
            if(side===0) { px = offset * w; pz = hd + rimR/2; } 
            else if(side===1) { px = offset * w; pz = -hd - rimR/2; }
            else if(side===2) { px = hw + rimR/2; pz = offset * d; } 
            else { px = -hw - rimR/2; pz = offset * d; }

            // –†–∞–Ω–¥–æ–º–Ω–∞—è –¥–ª–∏–Ω–∞ –∏ —à–∏—Ä–∏–Ω–∞
            const dropLen = (len || 40) * (0.6 + Math.random() * 0.7);
            const dropR = 0.4 + Math.random() * 0.5; // –¢—É—Ç —Ç–æ–∂–µ —Ä–∞–Ω–¥–æ–º

            const drop = new THREE.Mesh(new THREE.CylinderGeometry(dropR, dropR, dropLen, 8), mat);
            drop.geometry.translate(0, -dropLen/2, 0);
            drop.position.set(px, 0, pz);
            
            const tip = new THREE.Mesh(new THREE.SphereGeometry(dropR, 8, 8), mat);
            tip.position.y = -dropLen;
            drop.add(tip);
            
            grp.add(drop);
        }
    }

    return grp;
}

/* --- –õ–û–ì–ò–ö–ê –ü–û–î–¢–ï–ö–û–í --- */
function toggleDrips(enabled) {
    if(ui.selTier===null) return;
    const t = getActiveTiers()[ui.selTier];
    if(!t.drips) t.drips = { color: '#3e2723', len: 40, freq: 12 };
    t.drips.enabled = enabled;
    rebuildScene(); openMenu('color'); recordHistory();
}

function updateDrips(key, val) {
    if(ui.selTier===null) return;
    const t = getActiveTiers()[ui.selTier];
    if(key === 'len' || key === 'freq') val = parseInt(val);
    t.drips[key] = val;
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º "—É–º–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ" –±–µ–∑ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏ –º–µ–Ω—é –¥–ª—è –∏–Ω–ø—É—Ç–æ–≤
    if(key !== 'color') {
        const inputs = document.querySelectorAll('#sheet-content input[type=number]');
        inputs.forEach(inp => {
            const attr = inp.getAttribute('oninput');
            if(attr && attr.includes(`'${key}'`)) inp.value = val;
        });
    }
    rebuildScene(); recordHistory();
}

function stepDrips(key, delta) {
    if(ui.selTier===null) return;
    const t = getActiveTiers()[ui.selTier];
    let val = (t.drips[key] || 0) + delta;
    if(val < 1) val = 1;
    updateDrips(key, val);
}

/* --- –ö–û–ü–ò–†–û–í–ê–ù–ò–ï –î–ï–ö–û–†–ê --- */
function duplicateDecor() {
    if(ui.selTier===null) return;
    const tier = getActiveTiers()[ui.selTier];

    // –ö–æ–≥–æ –∫–æ–ø–∏—Ä—É–µ–º?
    let indicesToCopy = [];
    if (isMultiSelect && selectedDecors.length > 0) {
        indicesToCopy = [...selectedDecors]; // –ö–æ–ø–∏—è –º–∞—Å—Å–∏–≤–∞ –∏–Ω–¥–µ–∫—Å–æ–≤
        selectedDecors = []; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–±–æ—Ä, —á—Ç–æ–±—ã –≤—ã–¥–µ–ª–∏—Ç—å –ù–û–í–´–ï –∫–æ–ø–∏–∏
    } else if (ui.selDecorIdx !== null) {
        indicesToCopy = [ui.selDecorIdx];
    } else {
        return;
    }

    const newIndices = [];
    
    indicesToCopy.forEach(idx => {
        const src = tier.decor[idx];
        const copy = JSON.parse(JSON.stringify(src));
        
        // –°–¥–≤–∏–≥–∞–µ–º –∫–æ–ø–∏—é
        if (copy.placement === 'side') {
            copy.x = (copy.x || 0) + 0.05;
        } else {
            copy.x = (copy.x || 0) + 20; 
            copy.z = (copy.z || 0) + 20;
        }
        
        tier.decor.push(copy);
        newIndices.push(tier.decor.length - 1);
    });

    // –ï—Å–ª–∏ –±—ã–ª –º—É–ª—å—Ç–∏-—Ä–µ–∂–∏–º, –≤—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—ã–µ –∫–æ–ø–∏–∏
    if (isMultiSelect) {
        selectedDecors = newIndices;
    } else {
        ui.selDecorIdx = newIndices[0];
    }

    rebuildScene();
    openMenu('decor');
    recordHistory();
}

// 2. –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ –¥—Ä—É–≥–æ–π —Ç–æ—Ä—Ç (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø - –ë–ï–ó –õ–ò–®–ù–ï–ô –ü–û–î–°–í–ï–¢–ö–ò)
function copyDecorToOther() {
    if(ui.selTier===null || ui.selDecorIdx===null) return;
    
    // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–µ–ª—å
    const targetId = (activeCakeId === 0) ? 1 : 0;
    
    // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    if(typeof cakes === 'undefined' || !cakes[targetId]) {
        console.error("–û—à–∏–±–∫–∞: cakes –Ω–µ –Ω–∞–π–¥–µ–Ω"); return;
    }
    const targetTiers = cakes[targetId].tiers || cakes[targetId];
    if(!targetTiers || targetTiers.length === 0) {
        alert("–í—Ç–æ—Ä–æ–π —Ç–æ—Ä—Ç –ø—É—Å—Ç–æ–π! –î–æ–±–∞–≤—å—Ç–µ —è—Ä—É—Å."); return;
    }

    // 3. –ö–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
    const srcTier = getActiveTiers()[ui.selTier];
    const srcDecor = srcTier.decor[ui.selDecorIdx];
    const copy = JSON.parse(JSON.stringify(srcDecor));

    // –í—ã–±–∏—Ä–∞–µ–º —è—Ä—É—Å –Ω–∞ –Ω–æ–≤–æ–º —Ç–æ—Ä—Ç–µ
    let targetTierIdx = ui.selTier;
    if (targetTierIdx >= targetTiers.length) targetTierIdx = targetTiers.length - 1;
    
    if (!targetTiers[targetTierIdx].decor) targetTiers[targetTierIdx].decor = [];
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤
    targetTiers[targetTierIdx].decor.push(copy);
    const newDecorIdx = targetTiers[targetTierIdx].decor.length - 1;

    // 4. –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–ï –ò–ù–¢–ï–†–§–ï–ô–°–ê
    if(typeof viewMode !== 'undefined') {
        // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å—Ç–∞–≤–∏–º –æ–¥–∏–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º
        viewMode = 'single'; 
        activeCakeId = targetId; 
        
        // --- –û–ë–ù–û–í–õ–ï–ù–ò–ï –ö–ù–û–ü–û–ö (–ò–°–ü–†–ê–í–õ–ï–ù–û) ---
        const allBtns = document.querySelectorAll('button, .tab-btn, .cake-toggle');
        const targetChar = (targetId === 0) ? 'A' : 'B';

        allBtns.forEach(btn => {
            const txt = btn.innerText || '';
            const onclickAttrs = btn.getAttribute('onclick') || '';
            
            // –†–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ç–æ—Ä—Ç–æ–≤
            if (txt.includes('–¢–æ—Ä—Ç') || onclickAttrs.includes('Cake')) {
                
                // 1. –°–Ω–∞—á–∞–ª–∞ –≤—ã–∫–ª—é—á–∞–µ–º –í–°–Å
                btn.classList.remove('active');
                
                // 2. –í–∫–ª—é—á–∞–µ–º —Ç–æ–ª—å–∫–æ –¢–£ –°–ê–ú–£–Æ –∫–Ω–æ–ø–∫—É
                // –£—Å–ª–æ–≤–∏–µ:
                // –∞) –¢–µ–∫—Å—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω—É–∂–Ω—É—é –±—É–∫–≤—É (A –∏–ª–∏ B) –ò–õ–ò —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–∑—ã–≤–∞–µ—Ç –Ω—É–∂–Ω—ã–π ID (0 –∏–ª–∏ 1)
                // –±) –ù–û —Ç–µ–∫—Å—Ç –ù–ï —Å–æ–¥–µ—Ä–∂–∏—Ç "+" (—á—Ç–æ–±—ã –Ω–µ –∑–∞–∂–µ—á—å A+B)
                const isTarget = (txt.includes(targetChar) || onclickAttrs.includes(`(${targetId})`));
                const isDual = txt.includes('+') || txt.includes('A+B'); // –ö–Ω–æ–ø–∫–∞ "–û–±–∞"

                if (isTarget && !isDual) {
                    btn.classList.add('active');
                }
            }
        });
    }
    
    // 5. –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
    ui.selTier = targetTierIdx;
    ui.selDecorIdx = newDecorIdx;
    
    // 6. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ü–µ–Ω—É –∏ –º–µ–Ω—é
    rebuildScene();
    setTimeout(() => {
        openMenu('decor');
    }, 0);
}

/* --- –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–î–õ–û–ñ–ö–ò (BOARD) --- */
/* --- –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–î–õ–û–ñ–ö–ò (BOARD) --- */
function toggleBoard(checked) {
    if (ui.selTier === null) return;
    const t = getActiveTiers()[ui.selTier];
    // isRound: true –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–∞–∫ –≤—ã –ø—Ä–æ—Å–∏–ª–∏
    if (!t.board) t.board = { enabled: true, isRound: true, color: '#ffffff', thickness: 3, offset: 20 };
    t.board.enabled = checked;
    rebuildScene();
    openMenu('structure_edit'); 
    recordHistory();
}

function updateBoardProp(key, val) {
    if (ui.selTier === null) return;
    const t = getActiveTiers()[ui.selTier];
    if (!t.board) return;
    
    // –ï—Å–ª–∏ –ø—Ä–∏—à–ª–æ boolean –∑–Ω–∞—á–µ–Ω–∏–µ (–æ—Ç —á–µ–∫–±–æ–∫—Å–∞), —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
    if (typeof val === 'boolean') {
        t.board[key] = val;
    } else {
        // –ò–Ω–∞—á–µ –ø–∞—Ä—Å–∏–º —á–∏—Å–ª–æ
        if (key === 'thickness' || key === 'offset') val = parseFloat(val);
        t.board[key] = val;
    }
    
    if (key !== 'color' && typeof val !== 'boolean') {
        const inputs = document.querySelectorAll('#sheet-content input[type=number]');
        inputs.forEach(inp => {
            const attr = inp.getAttribute('oninput');
            if (attr && attr.includes(`'${key}'`)) inp.value = val;
        });
    }
    rebuildScene();
    recordHistory();
}

function stepBoardProp(key, delta) {
    if (ui.selTier === null) return;
    const t = getActiveTiers()[ui.selTier];
    if (!t.board) return;
    let val = (t.board[key] || 0) + delta;
    if (val < 0) val = 0;
    updateBoardProp(key, val);
}

/* --- –§–£–ù–ö–¶–ò–Ø –≠–ö–°–ü–û–†–¢–ê –í AR --- */
/* --- –§–ò–ù–ê–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –≠–ö–°–ü–û–†–¢–ê (–° –ò–º–µ–Ω–µ–º –∏ –í—ã–±–æ—Ä–æ–º) --- */
async function exportAR(format) {
    // 1. –ü–û–õ–£–ß–ê–ï–ú –ò–ú–Ø –ò–ó –ò–ù–ü–£–¢–ê
    const nameInput = document.getElementById('export-name');
    let fileName = nameInput ? nameInput.value : 'cake_ar';
    // –£–±–∏—Ä–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ–≥–æ —Å–ª—É—á–∞–π–Ω–æ –Ω–∞–ø–∏—Å–∞–ª
    fileName = fileName.replace(/\.(glb|usdz)$/i, '');
    if (!fileName) fileName = 'cake_ar';

    // 2. –ò–©–ï–ú –ù–£–ñ–ù–´–ô –¢–û–†–¢
    // 2. –ò–©–ï–ú –û–ë–™–ï–ö–¢(–´) –¢–û–†–¢–ê
    let sourceObj;
    if (viewMode === 'single') {
        // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω –æ–¥–∏–Ω —Ç–æ—Ä—Ç ‚Äî –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –µ–≥–æ
        sourceObj = group.children[activeCakeId === 0 ? 0 : (group.children.length > 1 ? 1 : 0)];
    } else {
        // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º A+B ‚Äî —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å—é –≥—Ä—É–ø–ø—É —Ü–µ–ª–∏–∫–æ–º
        sourceObj = group;
    }
    
    if (!sourceObj || (sourceObj.children && sourceObj.children.length === 0)) { 
        alert('–û—à–∏–±–∫–∞: –¢–æ—Ä—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'); return; 
    }

    // 3. –ü–û–î–ì–û–¢–û–í–ö–ê (–ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ)
    const objectToExport = sourceObj.clone();
    
    // –í–ê–ñ–ù–û: –ï—Å–ª–∏ –º—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –û–ë–ê —Ç–æ—Ä—Ç–∞ (viewMode === 'both'), 
    // –Ω–∞–º –ù–ï –ù–£–ñ–ù–û –¥–µ–ª–∞—Ç—å objectToExport.position.set(0, 0, 0), 
    // –∏–Ω–∞—á–µ –æ–Ω–∏ –≤—Å—Ç–∞–Ω—É—Ç –¥—Ä—É–≥ –≤ –¥—Ä—É–≥–∞. –°–º–µ—â–µ–Ω–∏–µ (-220 –∏ +220) –¥–æ–ª–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å—Å—è.
    if (viewMode === 'single') {
        objectToExport.position.set(0, 0, 0);
    }
    
      
    // 4. –û–ß–ò–°–¢–ö–ê (–£–¥–∞–ª—è–µ–º –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã)
    const toRemove = [];
    objectToExport.traverse((child) => {
        // –£–¥–∞–ª—è–µ–º –æ–±–≤–æ–¥–∫—É –≤—ã–¥–µ–ª–µ–Ω–∏—è
        if (child.isLineSegments || child.type === 'LineSegments' || child.type === 'Line') {
            toRemove.push(child);
        }
        // –£–¥–∞–ª—è–µ–º –ø–ª–∞—à–∫–∏ —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏ (–æ–Ω–∏ –ø–ª–æ—Ö–æ –≤—ã–≥–ª—è–¥—è—Ç –≤ AR)
        if (child.userData && child.userData.type === 'infoLabel') {
            toRemove.push(child);
        }
    });
    // –§–∏–∑–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ –º—É—Å–æ—Ä–∞
    toRemove.forEach(child => child.parent.remove(child));

    // 5. –ú–ê–°–®–¢–ê–ë–ò–†–û–í–ê–ù–ò–ï
    // 1 unit Three.js = 1 –º–µ—Ç—Ä AR.
    // –¢–æ—Ä—Ç 200–º–º = 0.2 –º–µ—Ç—Ä–∞. –£–º–µ–Ω—å—à–∞–µ–º –≤ 1000 —Ä–∞–∑.
    objectToExport.scale.set(0.001, 0.001, 0.001);
    objectToExport.updateMatrixWorld();

    // 6. –≠–ö–°–ü–û–†–¢ –í –ù–£–ñ–ù–´–ô –§–û–†–ú–ê–¢
    if (format === 'usdz') {
        // --- iPhone / iPad (.usdz) ---
        try {
            const exporter = new THREE.USDZExporter();
            const arraybuffer = await exporter.parse(objectToExport);
            const blob = new Blob([arraybuffer], { type: 'application/octet-stream' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName + '.usdz';
            link.click();
        } catch (e) {
            alert('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ USDZ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å.');
            console.error(e);
        }
        
    } else {
        // --- Android / Web (.glb) ---
        try {
            const exporter = new THREE.GLTFExporter();
            exporter.parse(
                objectToExport,
                function (gltf) {
                    const blob = new Blob([gltf], { type: 'application/octet-stream' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName + '.glb';
                    link.click();
                },
                { binary: true } // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ binary –¥–ª—è GLB
            );
        } catch (e) {
            alert('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ GLB.');
            console.error(e);
        }
    }
}

function addVolumeFigure(shapeType) {
    if(ui.selTier === null) { alert('–í—ã–±–µ—Ä–∏—Ç–µ —è—Ä—É—Å!'); return; }
    const t = getActiveTiers()[ui.selTier];
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —á–∏—Ç–∞–µ–º–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –¥–∞–Ω–Ω—ã—Ö
    const readableNames = { sphere: '–®–∞—Ä', cube: '–ö—É–±', cylinder: '–°–≤–µ—á–∞' };

    const item = { 
        url: '3d_prim', 
        placement: 'volume',
        shape: shapeType, 
        name: readableNames[shapeType], // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è –≤ –æ–±—ä–µ–∫—Ç
        w: 30, h: 30, rot: 0, 
        x: 0, y: 0, z: 0,
        color: '#ffffff',
        isText: false
    };
    
    t.decor.push(item);
    ui.selDecorIdx = t.decor.length - 1;
    rebuildScene();
    openMenu('decor');
    recordHistory();
}

function updateVolumeColor(val) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    if(d.placement !== 'volume') return;

    d.color = val;
    rebuildScene();
    // –ú—ã –Ω–µ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≤—Å—ë –º–µ–Ω—é (openMenu), —á—Ç–æ–±—ã –ø–æ–ª–∑—É–Ω–æ–∫ —Ü–≤–µ—Ç–∞ –Ω–µ "–ø—Ä—ã–≥–∞–ª" –ø—Ä–∏ –≤–≤–æ–¥–µ
    recordHistory();
}

function updateVolumeRotX(val) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    
    // –†–ê–ó–†–ï–®–ê–ï–ú –ò –¢–û–ü–ü–ï–†–´
    if(d.placement !== 'volume' && d.placement !== 'topper') return;

    d.rotX = parseFloat(val);
    rebuildScene();
    
    const range = document.querySelectorAll('input[type=range]')[1]; 
    if(range) range.value = val;
    recordHistory();
}

function updateVolumeRot(key, val) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];

    // –†–ê–ó–†–ï–®–ê–ï–ú –ò –¢–û–ü–ü–ï–†–´
    if(d.placement !== 'volume' && d.placement !== 'topper') return; // <--- –í–æ—Ç —Ç—É—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–µ
    
    d[key] = parseFloat(val);
    rebuildScene();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∏
    const labels = document.querySelectorAll('.control-label');
    labels.forEach(l => {
        if(key === 'rotX' && l.innerText.includes('–≤–ø–µ—Ä—ë–¥')) l.innerText = `–ù–∞–∫–ª–æ–Ω –≤–ø–µ—Ä—ë–¥/–Ω–∞–∑–∞–¥ (${d.rotX}¬∞)`;
        if(key === 'rotZ' && l.innerText.includes('–≤–ª–µ–≤–æ')) l.innerText = `–ù–∞–∫–ª–æ–Ω –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ (${d.rotZ}¬∞)`;
    });
    recordHistory();
}

function updateVolumeRot(key, val) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    
    d[key] = parseFloat(val);
    rebuildScene();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ —Å —Ü–∏—Ñ—Ä–∞–º–∏
    const labels = document.querySelectorAll('.control-label');
    labels.forEach(l => {
        if(key === 'rotX' && l.innerText.includes('–≤–ø–µ—Ä—ë–¥')) l.innerText = `–ù–∞–∫–ª–æ–Ω –≤–ø–µ—Ä—ë–¥/–Ω–∞–∑–∞–¥ (${d.rotX}¬∞)`;
        if(key === 'rotZ' && l.innerText.includes('–≤–ª–µ–≤–æ')) l.innerText = `–ù–∞–∫–ª–æ–Ω –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ (${d.rotZ}¬∞)`;
    });
    recordHistory();
}

function stepVolumeRot(key, delta) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    let val = (parseFloat(d[key]) || 0) + delta;
    updateVolumeRot(key, val);
    
    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –ø–æ–ª–∑—É–Ω–∫–∏ –≤–∏–∑—É–∞–ª—å–Ω–æ
    const ranges = document.querySelectorAll('input[type=range]');
    if (key === 'rotX' && ranges.length > 1) ranges[1].value = val;
    if (key === 'rotZ' && ranges.length > 2) ranges[2].value = val;
}

let isCompareMinimized = false;

function toggleCompare(e) {
    if(e) e.stopPropagation(); // –ß—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–∫–ª–∏–∫–∏–≤–∞–ª–æ—Å—å –Ω–∞ —Å—Ü–µ–Ω—É
    
    const el = document.getElementById('compare-overlay');
    const btn = el.querySelector('.cmp-toggle-btn');
    
    isCompareMinimized = !isCompareMinimized;

    if (isCompareMinimized) {
        el.classList.add('minimized');
        btn.innerHTML = '+'; // –ò–∫–æ–Ω–∫–∞ –ø–ª—é—Å–∞
    } else {
        el.classList.remove('minimized');
        btn.innerHTML = '‚Äì'; // –ò–∫–æ–Ω–∫–∞ –º–∏–Ω—É—Å–∞ (—Ç–∏—Ä–µ)
    }
}
/* --- –§–£–ù–ö–¶–ò–Ø –í–´–†–ê–í–ù–ò–í–ê–ù–ò–Ø (–ü–û –û–°–Ø–ú) --- */
function alignDecor(mode) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];

    if (mode === 'centerX') {
        d.x = 0; // –¶–µ–Ω—Ç—Ä –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ
    } 
    else if (mode === 'centerZ') {
        d.z = 0; // –¶–µ–Ω—Ç—Ä –±–ª–∏–∂–µ-–¥–∞–ª—å—à–µ
    }
    else if (mode === 'straight') {
        // –°–±—Ä–æ—Å –≤—Å–µ—Ö –Ω–∞–∫–ª–æ–Ω–æ–≤
        d.rot = 0;   
        d.rotX = 0;  
        d.rotZ = 0;  
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–ª–∑—É–Ω–∫–∏ –Ω–∞ —ç–∫—Ä–∞–Ω–µ
        const ranges = document.querySelectorAll('input[type=range]');
        ranges.forEach(r => r.value = 0);
    }

    rebuildScene();
    recordHistory();
}

function resetProject() {
    if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç? \n–í—Å–µ —Ç–µ–∫—É—â–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã –±–µ–∑–≤–æ–∑–≤—Ä–∞—Ç–Ω–æ.')) {
        
        // 1. –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        cakes = [[], []]; // –û—á–∏—â–∞–µ–º –æ–±–∞ —Ç–æ—Ä—Ç–∞
        
        // 2. –°–æ–∑–¥–∞–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π –ø–µ—Ä–≤—ã–π —è—Ä—É—Å –¥–ª—è –¢–æ—Ä—Ç–∞ –ê
        cakes[0].push({
            id: Date.now(), 
            shape: 'cylinder', 
            d: 200, h: 100, n: 6, w: 200, dep: 200, 
            color: '#ffffff', weight: 2, filling: '–í–∞–Ω–∏–ª—å', 
            tex: {side:defaultTex(), top:defaultTex(), bottom:defaultTex()}, 
            decor: []
        });

        // 3. –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        activeCakeId = 0;
        viewMode = 'single';
        ui.selTier = 0;
        ui.selDecorIdx = null;
        
        // 4. –û—á–∏—â–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é (—á—Ç–æ–±—ã –Ω–µ–ª—å–∑—è –±—ã–ª–æ –æ—Ç–º–µ–Ω–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞)
        history = [];
        historyPtr = -1;
        recordHistory();

        // 5. –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–¥
        switchCake(0); // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –≤–∏–¥ –æ–¥–Ω–æ–≥–æ —Ç–æ—Ä—Ç–∞
        rebuildScene();
        closeSheet(); // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é
    }
}
function toggleDecorLock(newState) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    
    d.locked = newState; // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å—Ç–∞–≤–∏–º —Ç–æ, —á—Ç–æ –ø–µ—Ä–µ–¥–∞–ª–∏
    
    // –ï—Å–ª–∏ –∑–∞–∫—Ä–µ–ø–∏–ª–∏ ‚Äî —Å—Ä–∞–∑—É —Å–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ, —á—Ç–æ–±—ã —Å–ª—É—á–∞–π–Ω–æ –Ω–µ —Å–¥–≤–∏–Ω—É—Ç—å
    if (d.locked) {
        // ui.selDecorIdx = null; // –ú–æ–∂–Ω–æ —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –º–µ–Ω—é –∑–∞–∫—Ä—ã–≤–∞–ª–æ—Å—å —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∏—è
    }
    
    openMenu('decor'); 
    recordHistory();
}
/* --- –õ–û–ì–ò–ö–ê –õ–ò–ù–ï–ô–ö–ò --- */
let rulerMode = false;
let rulerStep = 0; // 0: –∂–¥–µ–º –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É, 1: –∂–¥–µ–º –≤—Ç–æ—Ä—É—é
let rulerStart = new THREE.Vector3();
let rulerMarkerA, rulerMarkerB, rulerLine;

function toggleRuler() {
    rulerMode = !rulerMode;
    const btn = document.getElementById('btn-ruler');
    const label = document.getElementById('measure-label');
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –∑–∞–º–µ—Ä –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏
    clearRulerVisuals();
    rulerStep = 0;
    label.style.display = 'none';

    if (rulerMode) {
        btn.classList.add('active-tool');
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞–ª–æ
        closeSheet();
        ui.selDecorIdx = null; // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –æ–±—ä–µ–∫—Ç–æ–≤
        rebuildScene(); // –£–±–∏—Ä–∞–µ–º —Ä–∞–º–∫–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è
        alert('–†–µ–∂–∏–º –ª–∏–Ω–µ–π–∫–∏:\n1. –ù–∞–∂–º–∏—Ç–µ –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É.\n2. –ù–∞–∂–º–∏—Ç–µ –≤—Ç–æ—Ä—É—é —Ç–æ—á–∫—É.\n(–ß—Ç–æ–±—ã –≤—ã–π—Ç–∏, –Ω–∞–∂–º–∏—Ç–µ –∏–∫–æ–Ω–∫—É –ª–∏–Ω–µ–π–∫–∏ –µ—â–µ —Ä–∞–∑)');
    } else {
        btn.classList.remove('active-tool');
    }
}

function clearRulerVisuals() {
    if (rulerMarkerA) { scene.remove(rulerMarkerA); rulerMarkerA = null; }
    if (rulerMarkerB) { scene.remove(rulerMarkerB); rulerMarkerB = null; }
    if (rulerLine) { scene.remove(rulerLine); rulerLine = null; }
    document.getElementById('measure-label').style.display = 'none';
    renderer.render(scene, camera);
}

function createDot(pos, color) {
    const geo = new THREE.SphereGeometry(2, 16, 16); // –ú–∞–ª–µ–Ω—å–∫–∞—è —Ç–æ—á–∫–∞ 2–º–º
    const mat = new THREE.MeshBasicMaterial({ color: color, depthTest: false }); // depthTest: false —á—Ç–æ–±—ã –±—ã–ª–æ –≤–∏–¥–Ω–æ –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    mesh.renderOrder = 999; // –†–∏—Å—É–µ–º –ø–æ–≤–µ—Ä—Ö
    scene.add(mesh);
    return mesh;
}

function drawLine(p1, p2) {
    const mat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2, depthTest: false });
    const points = [p1, p2];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geo, mat);
    line.renderOrder = 999;
    scene.add(line);
    return line;
}

// –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –Ω–∞–∫–ª–µ–π–∫–∏ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏ –∫–∞–º–µ—Ä—ã)
function updateMeasureLabel() {
    if (!rulerMarkerA || !rulerMarkerB) return;
    
    // –ù–∞—Ö–æ–¥–∏–º —Å–µ—Ä–µ–¥–∏–Ω—É –ª–∏–Ω–∏–∏
    const midPoint = new THREE.Vector3().addVectors(rulerMarkerA.position, rulerMarkerB.position).multiplyScalar(0.5);
    
    // –ü—Ä–æ–µ—Ü–∏—Ä—É–µ–º 3D —Ç–æ—á–∫—É –≤ 2D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —ç–∫—Ä–∞–Ω–∞
    midPoint.project(camera);
    
    const x = (midPoint.x * .5 + .5) * window.innerWidth;
    const y = (-(midPoint.y * .5) + .5) * window.innerHeight;
    
    const label = document.getElementById('measure-label');
    label.style.left = x + 'px';
    label.style.top = y + 'px';
    
}

/* --- –õ–û–ì–ò–ö–ê –ú–£–õ–¨–¢–ò-–í–´–ë–û–†–ê --- */
function toggleMultiSelectMode() {
    isMultiSelect = !isMultiSelect;
    selectedDecors = []; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–±–æ—Ä –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏
    if (!isMultiSelect) {
        ui.selDecorIdx = null; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∏ –æ–±—ã—á–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
    }
    openMenu('decor');
    rebuildScene();
}

function toggleDecorSelection(index) {
    const pos = selectedDecors.indexOf(index);
    if (pos === -1) {
        selectedDecors.push(index);
    } else {
        selectedDecors.splice(pos, 1);
    }
    rebuildScene();
    
    // –í–ê–ñ–ù–û: –ü–µ—Ä–µ–¥–∞–µ–º index –≤—Ç–æ—Ä—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º, —á—Ç–æ–±—ã –º–µ–Ω—é –∑–Ω–∞–ª–æ, –∫–æ–≥–æ –¥–µ—Ä–∂–∞—Ç—å –≤ –ø–æ–ª–µ –∑—Ä–µ–Ω–∏—è
    openMenu('decor', index); 
}

function groupAction(action) {
    if (ui.selTier === null || selectedDecors.length === 0) return;
    const tier = getActiveTiers()[ui.selTier];
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏–Ω–¥–µ–∫—Å—ã –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
    const sortedIndices = [...selectedDecors].sort((a,b) => b-a);

    sortedIndices.forEach(idx => {
        const d = tier.decor[idx];
        if (action === 'lock') d.locked = true;
        if (action === 'unlock') d.locked = false;
        if (action === 'delete') {
            tier.decor.splice(idx, 1);
        }
    });

    if (action === 'delete') {
        selectedDecors = []; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–±–æ—Ä –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è
    }

    rebuildScene();
    openMenu('decor');
    recordHistory();
}
/* --- –§–£–ù–ö–¶–ò–Ø –°–û–ó–î–ê–ù–ò–Ø –°–ò–ú–ú–ï–¢–†–ò–ò --- */
function makeSymmetry(count) {
    if (ui.selTier === null || ui.selDecorIdx === null) {
        alert("–í—ã–±–µ—Ä–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç –¥–µ–∫–æ—Ä–∞!"); 
        return;
    }

    const tier = getActiveTiers()[ui.selTier];
    const source = tier.decor[ui.selDecorIdx];

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã —Å–∏–º–º–µ—Ç—Ä–∏–∏
    const symId = Date.now() + '_' + Math.random();
    
    // –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º ID –∏—Å—Ö–æ–¥–Ω–æ–º—É –æ–±—ä–µ–∫—Ç—É
    source.symId = symId;

    // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏–∏
    for (let i = 1; i < count; i++) {
        // –ö–ª–æ–Ω–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
        const clone = JSON.parse(JSON.stringify(source));
        
        // –°—á–∏—Ç–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –∫–æ–ø–∏–∏
        // –î–ª—è —Å—Ç–∏–∫–µ—Ä–æ–≤ (side) x ‚Äî —ç—Ç–æ –ø—Ä–æ–≥—Ä–µ—Å—Å 0..1 –ø–æ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏
        if (source.placement === 'side') {
            clone.x = (source.x + (i / count)) % 1; 
        } 
        // –î–ª—è 3D –æ–±—ä–µ–∫—Ç–æ–≤ (topper, volume) –Ω—É–∂–Ω–æ –≤—Ä–∞—â–∞—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–æ–∫—Ä—É–≥ —Ü–µ–Ω—Ç—Ä–∞
        else {
            // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –¥—É–±–ª–∏—Ä—É–µ–º, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–∞–º —Ä–∞—Å—Ç–∞—â–∏—Ç? 
            // –ù–µ—Ç, –Ω–∞–¥–æ —Ä–∞—Å—Å—Ç–∞–≤–∏—Ç—å –∫—Ä–∞—Å–∏–≤–æ —Å—Ä–∞–∑—É.
            // –ù–æ —É –Ω–∞—Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã x, z –ª–∏–Ω–µ–π–Ω—ã–µ. –°–ª–æ–∂–Ω–æ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –±–µ–∑ –ø–æ–ª—è—Ä–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.
            // –î–õ–Ø SIDE (–°—Ç–∏–∫–µ—Ä—ã) —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏–¥–µ–∞–ª—å–Ω–æ —Å—Ä–∞–∑—É.
            // –î–õ–Ø 3D –æ–±—ä–µ–∫—Ç–æ–≤ (—è–≥–æ–¥—ã –Ω–∞–≤–µ—Ä—Ö—É) —Å–¥–µ–ª–∞–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω–æ: 
            // –≠—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç —Å—Ç–æ–∏—Ç –Ω–µ –≤ —Ü–µ–Ω—Ç—Ä–µ (0,0).
            
            // –ï—Å–ª–∏ —ç—Ç–æ –æ–±—ä–µ–∫—Ç –Ω–∞ –∫—Ä—ã—à–∫–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º "–≤—Ä–∞—â–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞"
            const angle = (i / count) * Math.PI * 2;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            const x0 = source.x || 0;
            const z0 = source.z || 0;
            
            // –ü–æ–≤–æ—Ä–æ—Ç —Ç–æ—á–∫–∏ (x0, z0) –Ω–∞ —É–≥–æ–ª angle
            clone.x = x0 * cos - z0 * sin;
            clone.z = x0 * sin + z0 * cos;
            
            // –ü–æ–≤–æ—Ä–æ—Ç —Å–∞–º–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ —Ç–æ–∂–µ –Ω—É–∂–µ–Ω!
            clone.rot = (source.rot || 0) - (angle * 180 / Math.PI); 
        }
        
        clone.symId = symId; // –°–≤—è–∑—ã–≤–∞–µ–º —Å "–º–∞–º–æ–π"
        tier.decor.push(clone);
    }

    rebuildScene();
    openMenu('decor'); // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ —Å–ª–æ–µ–≤
    recordHistory();
    
    alert(`–°–æ–∑–¥–∞–Ω–∞ —Å–∏–º–º–µ—Ç—Ä–∏—è x${count}! –¢–µ–ø–µ—Ä—å –¥–≤–∏–≥–∞–π—Ç–µ –ª—é–±–æ–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –≥—Ä—É–ø–ø—ã.`);
}
/* --- –§–£–ù–ö–¶–ò–Ø –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ù–ê–ü–†–ê–í–õ–Ø–Æ–©–ò–ú–ò --- */
function updateSnapLines(visibleX, visibleZ, pos) {
    // 1. –°–æ–∑–¥–∞–µ–º –ª–∏–Ω–∏–∏, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
    if (!snapLines.x) {
        const mat = new THREE.LineBasicMaterial({ color: 0xff0000, transparent:true, opacity:0.6 }); // –ö—Ä–∞—Å–Ω–∞—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -1000, 0), new THREE.Vector3(0, 1000, 0)]);
        snapLines.x = new THREE.Line(geo, mat);
        scene.add(snapLines.x);
    }
    if (!snapLines.z) {
        const mat = new THREE.LineBasicMaterial({ color: 0x0000ff, transparent:true, opacity:0.6 }); // –°–∏–Ω—è—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-1000, 0, 0), new THREE.Vector3(1000, 0, 0)]);
        snapLines.z = new THREE.Line(geo, mat);
        scene.add(snapLines.z);
    }

    // 2. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/–°–∫—Ä—ã–≤–∞–µ–º –∏ –¥–≤–∏–≥–∞–µ–º X (–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è)
    // –û–Ω–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ü–µ–Ω—Ç—Ä –ø–æ X (–∫—Ä–∞—Å–Ω–∞—è –ª–∏–Ω–∏—è –≤–¥–æ–ª—å Y)
    if (visibleX) {
        snapLines.x.visible = true;
        snapLines.x.position.set(pos.x, 0, pos.z); // –°—Ç–∞–≤–∏–º –ª–∏–Ω–∏—é –≤ —Ç–æ—á–∫—É –æ–±—ä–µ–∫—Ç–∞
        // –ù–æ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞ X –Ω–∞–º –Ω—É–∂–Ω–∞ –ª–∏–Ω–∏—è, –ø—Ä–æ—Ö–æ–¥—è—â–∞—è —á–µ—Ä–µ–∑ X=0.
        // –ü–æ—ç—Ç–æ–º—É –¥–ª—è "–¶–µ–Ω—Ç—Ä–∞" –º—ã –∂–µ—Å—Ç–∫–æ —Å—Ç–∞–≤–∏–º –µ—ë –≤ 0.
        // –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–ª–∏–ø–∞—Ç—å –∫ –∫—Ä–∞—è–º, –ª–æ–≥–∏–∫–∞ –±—É–¥–µ—Ç —Å–ª–æ–∂–Ω–µ–µ. –ü–æ–∫–∞ –¥–µ–ª–∞–µ–º –¶–ï–ù–¢–†.
        snapLines.x.position.set(0, 0, 0); 
    } else {
        snapLines.x.visible = false;
    }

    // 3. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/–°–∫—Ä—ã–≤–∞–µ–º Z (–õ–∏–Ω–∏—è –≥–ª—É–±–∏–Ω—ã)
    if (visibleZ) {
        snapLines.z.visible = true;
        snapLines.z.position.set(0, pos.y, 0); // –£—Ä–æ–≤–µ–Ω—å –≤—ã—Å–æ—Ç—ã? –ù–µ—Ç, —Ü–µ–Ω—Ç—Ä —Å—Ç–æ–ª–∞.
        snapLines.z.position.set(0, 0, 0);
        snapLines.z.rotation.y = Math.PI / 2; // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ø–æ–ø–µ—Ä–µ–∫
    } else {
        snapLines.z.visible = false;
    }
}
function updateDecorTint(val) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    
    d.tintColor = val;
    rebuildScene();
    // –ú—ã –Ω–µ –≤—ã–∑—ã–≤–∞–µ–º recordHistory –ø—Ä–∏ –∫–∞–∂–¥–æ–º –¥–≤–∏–∂–µ–Ω–∏–∏ –ø–æ–ª–∑—É–Ω–∫–∞ —Ü–≤–µ—Ç–∞, —á—Ç–æ–±—ã –Ω–µ –∑–∞–±–∏–≤–∞—Ç—å –ø–∞–º—è—Ç—å,
    // –Ω–æ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å, –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ.
}
function renameDecor(val) {
    if(ui.selTier === null || ui.selDecorIdx === null) return;
    
    const d = getActiveTiers()[ui.selTier].decor[ui.selDecorIdx];
    d.customName = val; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è
    
    openMenu('decor'); // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é, —á—Ç–æ–±—ã –Ω–æ–≤–æ–µ –∏–º—è –ø–æ—è–≤–∏–ª–æ—Å—å –≤ —Å–ø–∏—Å–∫–µ
    recordHistory();
}

function updateCakeGap(val) {
    cakeGap = parseInt(val);
    rebuildScene(); // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å—Ü–µ–Ω—É —Å –Ω–æ–≤—ã–º –æ—Ç—Å—Ç—É–ø–æ–º
    // –ö–∞–º–µ—Ä—É –Ω–µ –º–µ–Ω—è–µ–º, —á—Ç–æ–±—ã –Ω–µ —Å–±–∏–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É, –ø—Ä–æ—Å—Ç–æ –¥–≤–∏–≥–∞–µ–º —Ç–æ—Ä—Ç—ã
}

/* --- –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê DRAG (–£–ù–ò–í–ï–†–°–ê–õ–¨–ù–ê–Ø) --- */
const sheetEl = document.getElementById('bottom-sheet');
const dragEl = document.getElementById('sheet-drag-handle');
let dragStartY, dragStartH, isSheetDragging = false;

// –ò—Å–ø–æ–ª—å–∑—É–µ–º pointerdown –≤–º–µ—Å—Ç–æ touchstart (—Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –º—ã—à—å, –∏ –ø–∞–ª–µ—Ü)
dragEl.addEventListener('pointerdown', (e) => {
    // 1. –ë–ª–æ–∫–∏—Ä—É–µ–º –≤—Å–ø–ª—ã—Ç–∏–µ, —á—Ç–æ–±—ã –Ω–µ –≤—Ä–∞—â–∞–ª–∞—Å—å –∫–∞–º–µ—Ä–∞
    e.stopPropagation(); 
    
    isSheetDragging = true;
    dragStartY = e.clientY; // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ Y –Ω–∞–∂–∞—Ç–∏—è
    dragStartH = sheetEl.getBoundingClientRect().height; // –¢–µ–∫—É—â–∞—è –≤—ã—Å–æ—Ç–∞
    
    sheetEl.style.transition = 'none'; // –û—Ç–∫–ª—é—á–∞–µ–º –ø–ª–∞–≤–Ω–æ—Å—Ç—å –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –æ—Ç–∫–ª–∏–∫–∞
    
    // 2. "–ó–∞—Ö–≤–∞—Ç" –∫—É—Ä—Å–æ—Ä–∞. –°–æ–±—ã—Ç–∏—è –±—É–¥—É—Ç –∏–¥—Ç–∏ –Ω–∞ —ç—Ç–æ—Ç —ç–ª–µ–º–µ–Ω—Ç, –¥–∞–∂–µ –µ—Å–ª–∏ –ø–∞–ª–µ—Ü —É—à–µ–ª –≤ —Å—Ç–æ—Ä–æ–Ω—É
    dragEl.setPointerCapture(e.pointerId);
});

dragEl.addEventListener('pointermove', (e) => {
    if (!isSheetDragging) return;
    
    // 3. –°—á–∏—Ç–∞–µ–º —Ä–∞–∑–Ω–∏—Ü—É (—Ç—è–Ω–µ–º –≤–≤–µ—Ä—Ö = Y —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è, –∑–Ω–∞—á–∏—Ç —Ä–∞–∑–Ω–∏—Ü–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–∞—è –¥–ª—è –≤—ã—Å–æ—Ç—ã)
    const delta = dragStartY - e.clientY; 
    const newH = dragStartH + delta;
    
    // 4. –û–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª–∏ –≤—ã—Å–æ—Ç—ã (–≤ –ø–∏–∫—Å–µ–ª—è—Ö)
    const maxH = window.innerHeight * 0.95; // –ù–µ –±–æ–ª—å—à–µ 95% —ç–∫—Ä–∞–Ω–∞
    const minH = window.innerHeight * 0.15; // –ù–µ –º–µ–Ω—å—à–µ 15% —ç–∫—Ä–∞–Ω–∞
    
    if(newH > maxH || newH < minH) return;
    
    sheetEl.style.height = newH + 'px';
});

// –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
const stopDrag = (e) => {
    if (!isSheetDragging) return;
    isSheetDragging = false;
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–ª–∞–≤–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é
    sheetEl.style.transition = 'height 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)'; 
    dragEl.releasePointerCapture(e.pointerId);
};

dragEl.addEventListener('pointerup', stopDrag);
dragEl.addEventListener('pointercancel', stopDrag);
init();
</script>
  <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => console.log('Service Worker registered', reg))
        .catch(err => console.log('SW registration failed', err));
    });
  }
</script>
</body>
</html>







